{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"In\u00edcio","text":"<p>B. B. King</p> <p>A beleza do aprendizado \u00e9 que ningu\u00e9m pode tir\u00e1-lo de voc\u00ea.</p> <p>A tecnologia est\u00e1 cada vez mais presente em nossa sociedade, e um fator determinante neste processo \u00e9 o uso de computadores nas tarefas. Esta ferramenta consegue atuar em contextos t\u00e3o diversos porque \u00e9 feita para executar as instru\u00e7\u00f5es que lhe damos. A resolu\u00e7\u00e3o dos problemas \u00e9 consequ\u00eancia direta de conseguirmos determinar um conjunto adequado de instru\u00e7\u00f5es, tanto no sentido de guiarem o processo computacional para o resultado desejado quanto no de utilizar corretamente a m\u00e1quina dentro de suas limita\u00e7\u00f5es. O objetivo deste livro, portanto, \u00e9 ajudar a desenvolver as capacidades de resolver problemas e de executar suas solu\u00e7\u00f5es em computadores.</p> <p>O conte\u00fado apresentado envolve alguns conceitos e pr\u00e1ticas envolvidos nesta atividade. Ele serve para abrir as portas da computa\u00e7\u00e3o para iniciantes. Nenhum conhecimento pr\u00e9vio \u00e9 necess\u00e1rio, mas facilidade com l\u00f3gica \u00e9 uma grande vantagem. A qualidade do aprendizado est\u00e1 intrinsecamente ligada \u00e0 consolida\u00e7\u00e3o da teoria pela realiza\u00e7\u00e3o das atividades pr\u00e1ticas propostas.</p> <p>A ideia \u00e9 familiarizar o leitor com os principais conceitos envolvidos na concep\u00e7\u00e3o de um conjunto de instru\u00e7\u00f5es (um algoritmo) e no processo de representa\u00e7\u00e3o delas como c\u00f3digo fonte (um programa), de modo que se possa utilizar um computador para realizar esta tarefa. Em outras palavras, desenvolver o \"pensamento computacional\" do leitor de modo que seja capaz de criar e implementar uma solu\u00e7\u00e3o computacional para um problema.</p> Formata\u00e7\u00e3o <p>Este livro usa as seguintes conven\u00e7\u00f5es para destacar algumas informa\u00e7\u00f5es.</p> Algoritmo / Programa<pre><code>Apresenta um algoritmo ou programa.\n</code></pre> <p>Aten\u00e7\u00e3o</p> <p>Apresenta um aviso sobre uma situa\u00e7\u00e3o recorrente no contexto.</p> <p>Chatbot</p> <p>Indica pontos que podem ser melhor desenvolvidos com o apoio de intelig\u00eancia artificial.</p> <p>Defini\u00e7\u00e3o</p> <p>Apresenta a defini\u00e7\u00e3o de um conceito.</p> <p>Dica</p> <p>Apresenta uma informa\u00e7\u00e3o ou sugest\u00e3o relevante no contexto.</p> <p>Exerc\u00edcios</p> <p>Apresenta exerc\u00edcios para pr\u00e1tica e acompanhamento do conte\u00fado te\u00f3rico.</p> <p>Resumo</p> <p>Apresenta o resumo do conte\u00fado.</p> Por fim... <p>Este texto foi criado usando ferramentas livres como o mkdocs, Wikimedia Commons e app.diagrams.net.</p> <p>Boa leitura!</p>"},{"location":"algoritmos/","title":"Algoritmos","text":"<p>Thomas H. Cormen</p> <p>Antes de existirem computadores, j\u00e1 havia algoritmos. Mas agora que os computadores existem, h\u00e1 ainda mais algoritmos, e os algoritmos s\u00e3o a base da computa\u00e7\u00e3o.</p> <p>Este cap\u00edtulo apresenta o conceito de algoritmo e algumas formas de represent\u00e1-lo. Ao final do texto, espera-se que se tenha um entendimento claro do que envolve este conceito e capacidade de expressar solu\u00e7\u00f5es como algoritmos.</p> <p>Algoritmos s\u00e3o \"m\u00e9todos\" ou instru\u00e7\u00f5es para realizar uma tarefa. Por exemplo, \u00e9 relativamente simples seguir os passos de uma receita para obter um bolo, seguir uma rota para chegar ao destino desejado, ou calcular um valor matem\u00e1tico. Para tanto, basta que se consiga entender e realizar cada etapa descrita.</p> <p>Um algoritmo descreve o processo para se obter um resultado, e espera-se que este resultado seja alcan\u00e7ado independentemente de quem esteja seguindo os passos. Pessoas diferentes seguindo uma mesma receita deveriam produzir o mesmo bolo, chegar ao mesmo local e obter o mesmo valor. Entretanto, seres humanos s\u00e3o muito inteligentes, e conseguem abstrair detalhes e inferir uma s\u00e9rie de informa\u00e7\u00f5es ausentes em sua comunica\u00e7\u00e3o. Considere o algoritmo abaixo, a maioria dos rec\u00e9m ingressos \u00e0 universidade n\u00e3o teria dificuldade em resolv\u00ea-lo com sucesso.</p> M\u00e9dia Aritm\u00e9tica<pre><code>Leia quatro n\u00fameros e calcule a m\u00e9dia aritm\u00e9tica.\n</code></pre> <p>Apesar da aparente simplicidade, ele apresenta diversas poss\u00edveis interpreta\u00e7\u00f5es. \"Leia quatro n\u00fameros\" significa ler todos de uma s\u00f3 vez ou um da cada vez? \"Calcule a m\u00e9dia aritm\u00e9tica\" se refere a de todos os n\u00fameros fornecidos, a de parte deles ou a de outros n\u00fameros n\u00e3o especificados? \u00c9 garantido que a pessoa a realizar a tarefa reconhece o termo \"m\u00e9dia aritm\u00e9tica\"? O que fazer com o resultado calculado?</p> <p>\u00c9 poss\u00edvel, portanto, que algu\u00e9m leia 2357, considere que este valor \u00fanico \u00e9 composto por \"quatro n\u00fameros\" (ignorando que representam apenas um valor), e calcule mentalmente a m\u00e9dia aritm\u00e9tica deles como 4 (j\u00e1 que a parte fracion\u00e1ria \u00e9 \"uma conta mais dif\u00edcil\"). Se voc\u00ea esperava que lhe fosse dito o valor exato de 4.25, ficaria desapontado...</p> <p>Esta varia\u00e7\u00e3o (e outras poss\u00edveis) n\u00e3o parece ser a forma mais \u00f3bvia de se resolver o problema, mas nem por isso est\u00e1 errada considerando a forma como as instru\u00e7\u00f5es foram apresentadas no algoritmo. A ideia por tr\u00e1s do conceito de algoritmo \u00e9 descrever um processo de modo que os mesmos resultados possam ser obtidos independentemente de que executa os passos. \u00c9 f\u00e1cil enxergar isso considerando uma receita de bolo sendo compartilhada: se for bem detalhada, mesmo uma pessoa que nunca cozinhou na vida consegue chegar ao resultado desejado. Portanto, buscamos essa descri\u00e7\u00e3o do processo que permite garantir o resultado e abstrair do contexto \"quem\" (ou \"o que\") realiza o esfor\u00e7o.</p> <p>Dica</p> <p>A principal caracter\u00edstica de um algoritmo \u00e9 sua corretude, ou seja, sua capacidade de realizar corretamente a tarefa conforme a especifica\u00e7\u00e3o.</p> <p>O computador \u00e9 uma ferramenta fant\u00e1stica que faz, muito rapidamente, exatamente o que pedimos - desde que esta solicita\u00e7\u00e3o seja feita de um modo que a m\u00e1quina consiga interpretar de forma inequ\u00edvoca. O objetivo se torna, portanto, definir um algoritmo computacional, ou seja, descrever as instru\u00e7\u00f5es do algoritmo de um modo espec\u00edfico e detalhado o suficiente para que o computador possa interpret\u00e1-las para realizar a tarefa em quest\u00e3o1.</p> <p>Algoritmo Computacional</p> <p>Uma sequ\u00eancia finita de instru\u00e7\u00f5es bem definidas para realizar uma tarefa com um computador.</p> <p>H\u00e1 discuss\u00f5es interessantes sobre a defini\u00e7\u00e3o precisa do conceito de um algoritmo computacional, mas as todas convergem no pontos mais importantes2. A sequ\u00eancia de instru\u00e7\u00f5es deve ser finita porque o objetivo \u00e9 realizar a tarefa, portanto a execu\u00e7\u00e3o deve terminar. As instru\u00e7\u00f5es utilizadas devem ser bem especificadas e com apenas uma interpreta\u00e7\u00e3o poss\u00edvel, de modo que o computador saiba exatamente o que fazer a cada passo. A realiza\u00e7\u00e3o da tarefa tamb\u00e9m pode lidar com entrada de dados e sa\u00edda de dados, ou seja, o algoritmo pode receber informa\u00e7\u00f5es externas necess\u00e1rias para a realiza\u00e7\u00e3o da tarefa e fornecer informa\u00e7\u00f5es resultantes deste processo. Por fim, os passos devem ser apresentados de tal forma que seja poss\u00edvel para o computador entender e executar cada um deles.</p> <p>Existem diversas formas de representar de um algoritmo e n\u00e3o h\u00e1 consenso de qual \u00e9 a melhor delas. Independentemente, o algoritmo deve ser representado da forma mais clara poss\u00edvel para facilitar seu entendimento por quem vai execut\u00e1-lo. Apresentamos a seguir algumas possibilidades.</p>"},{"location":"algoritmos/#descricao-narrativa","title":"Descri\u00e7\u00e3o Narrativa","text":"<p>A forma mais intuitiva de apresentar uma sequ\u00eancia de instru\u00e7\u00f5es, pois usa linguagem natural para faz\u00ea-lo, como no algoritmos de m\u00e9dia aritm\u00e9tica. Apesar de parecer simples por ser a forma que estamos acostumados a usar para comunica\u00e7\u00e3o, \u00e9 extremamente complexa pois considera a enorme capacidade humana de inferir coisas a partir de informa\u00e7\u00e3o incompleta.</p> <p>Essa \"facilidade\" inerente tem um contraponto: as instru\u00e7\u00f5es que usamos n\u00e3o s\u00e3o muito bem definidas e, portanto, o resultado obtido pode ser diferente do esperado dependendo de quem as interpreta. Por exemplo, considere o seguinte algoritmo:</p> Receita de Bolo<pre><code>Bata as claras em neve. Reserve. Bata bem as gemas com a margarina e o a\u00e7\u00facar. Acrescente o leite e farinha aos poucos sem parar de bater. Por \u00faltimo agregue as claras em neve e o fermento. Coloque em forma grande de furo central untada e enfarinhada. Asse em forno m\u00e9dio, pr\u00e9-aquecido, por aproximadamente 40 min. Quando espetar um palito e sair limpo estar\u00e1 assado.\n</code></pre> <p>Para algu\u00e9m que n\u00e3o esteja acostumado a atividades na cozinha, o algoritmo \u00e9 amb\u00edguo e impreciso. Como bater as claras? Por quanto tempo? Reservar o que? Onde? O que \u00e9 \"bater bem\"? Acrescentar o leite a que? Bater o que sem parar? Se n\u00e3o parar como posso fazer as outras coisas? Colocar o que na forma? O que \u00e9 \"enfarinhada\"? Assar a quantos graus? \"Aproximadamente\" s\u00e3o quantos minutos? Espetar o palito onde? O que \u00e9 \"limpo\"? O palito estar\u00e1 assado?</p> <p>Uma descri\u00e7\u00e3o narrativa detalhada o suficiente para evitar qualquer falha na interpreta\u00e7\u00e3o tende a ser bem mais extensa (e menos natural) do que estamos acostumados a utilizar em nossas conversas do dia a dia.</p>"},{"location":"algoritmos/#fluxograma","title":"Fluxograma","text":"<p>Outro jeito bastante intuitivo com o uso de figuras geom\u00e9tricas, como pode ser vista nos diagramas abaixo.</p> <pre><code>flowchart TD\n    I([In\u00edcio]) --&gt; EF{Entende&lt;br&gt;fluxogramas?}\n    EF --&gt;|Sim| O[/\u00d3timo!/] --&gt; F([Fim])\n    EF --&gt;|N\u00e3o| VLS{V\u00ea a linha&lt;br&gt;com 'Sim'?}\n    VLS --&gt;|Sim| VLN{E a com&lt;br&gt;'N\u00e3o'?} --&gt;|Sim| O\n    VLS --&gt;|N\u00e3o| ES[\u00c9 a outra&lt;br&gt;linha...]  --&gt; VLS\n    VLN --&gt;|N\u00e3o| MJ[/Mas j\u00e1&lt;br&gt;seguiu v\u00e1rias?!/] --&gt; SS[Siga a seta.] --&gt; VLS\n</code></pre> <p>Cada forma geom\u00e9trica tem um significado especifico mas, para facilitar, usaremos apenas as a seguir:</p> <ul> <li>Terminal: que indica onde o algoritmo inicia e onde termina.</li> <li>Dado(s): que indica a comunica\u00e7\u00e3o (entrada/sa\u00edda) de dado(s) com o algoritmo.</li> <li>Processo: que indica a execu\u00e7\u00e3o de uma instru\u00e7\u00e3o/tarefa.</li> <li>Decis\u00e3o: que indica a necessidade de se escolher uma (e apenas uma!) das diversas poss\u00edveis a\u00e7\u00f5es subsequentes.</li> <li>Seta: que indica a sequ\u00eancia em que as instru\u00e7\u00f5es ser\u00e3o executadas.</li> </ul> <pre><code>flowchart TD\n    I([Terminal]) --&gt;|seta| P[Processo] &amp; D{Decis\u00e3o} &amp; IO[/Entrada&lt;br&gt;Sa\u00edda/]\n</code></pre> <p>Geralmente se usa instru\u00e7\u00f5es mais diretas e simples que na descri\u00e7\u00e3o narrativa, tamb\u00e9m em fun\u00e7\u00e3o da limita\u00e7\u00e3o das figuras utilizadas. Isso tem dois efeitos muito interessantes: o uso de fluxograma restringe muito a amplitude do entendimento das instru\u00e7\u00f5es, facilitando a constru\u00e7\u00e3o de instru\u00e7\u00f5es bem definidas para o algoritmo; mas tamb\u00e9m restringe o tipo de instru\u00e7\u00f5es utiliz\u00e1veis, dificultando a constru\u00e7\u00e3o do processo desejado - podem ser necess\u00e1rias mais instru\u00e7\u00f5es para descrever adequadamente um peda\u00e7o mais complexo do comportamento.</p>"},{"location":"algoritmos/#pseudocodigo","title":"Pseudoc\u00f3digo","text":"<p>Outra abordagem bem interessante, pois visa diminuir o esfor\u00e7o de traduzir um algoritmo computacional em instru\u00e7\u00f5es que um computador possa usar. Utiliza termos simples e estruturas de uma linguagem de programa\u00e7\u00e3o, mas com sintaxe e regras menos restritivas. Por exemplo, o algoritmo abaixo em pseudoc\u00f3digo.</p> M\u00e9dia Aritm\u00e9tica<pre><code>In\u00edcio\n    Leia [nota_1]\n    Leia [nota_2]\n    Leia [nota_3]\n    Leia [nota_4]\n    m\u00e9dia  = (nota_1 + nota_2 + nota_3 + nota_4) \u00f7 4\n    Escreva o valor da [m\u00e9dia]\nFim\n</code></pre> <p>Note que o algoritmo da m\u00e9dia em pseudoc\u00f3digo come\u00e7a e termina com duas palavras, <code>In\u00edcio</code> e <code>Fim</code>. Estas, como as palavras <code>Leia</code> e <code>Escreva</code>, pertencem ao que chamamos de vocabul\u00e1rio controlado. O uso deste um conjunto mais restrito de palavras possibilita maior precis\u00e3o e efic\u00e1cia na comunica\u00e7\u00e3o das instru\u00e7\u00f5es.</p> <p>Outro diferencial \u00e9 a considera\u00e7\u00e3o de nomear as informa\u00e7\u00f5es, de modo a poder recuper\u00e1-las em passos subsequentes. Por exemplo, a segunda instru\u00e7\u00e3o obt\u00e9m um valor (comunica\u00e7\u00e3o de um dado) e lhe atribui um nome (<code>nota_1</code>); que \u00e9 recuperado no momento de calcular a soma dos n\u00fameros, na sexta instru\u00e7\u00e3o.</p> <p>Por fim, note tamb\u00e9m que as linhas com as instru\u00e7\u00f5es de cada passo do algoritmo est\u00e3o deslocadas para a direita em rela\u00e7\u00e3o \u00e0s palavras destacadas, ressaltando o conjunto de instru\u00e7\u00f5es dentro do bloco definido por elas. Este deslocamento \u00e9 denominado endenta\u00e7\u00e3o, e facilita a visualiza\u00e7\u00e3o da estrutura do algoritmo.</p> <p>Este detalhamento das instru\u00e7\u00f5es implica que o algoritmo com m\u00e9dia em pseudoc\u00f3digo ficou mais extenso e menos \"natural\" que o mesmo processo descrito no da m\u00e9dia detalhada, mas \u00e9 bem melhor definido e continua sendo de f\u00e1cil entendimento. Al\u00e9m disso, se aproxima mais da forma de representar um algoritmo como uma linguagem de programa\u00e7\u00e3o.</p>"},{"location":"algoritmos/#codigo","title":"C\u00f3digoResumoExerc\u00edcios","text":"<p>A representa\u00e7\u00e3o mais interessante de um algoritmo, pois pode ser diretamente aplicada a um computador. O algoritmo \u00e9 descrito como um programa de computador, ou seja, utilizando o vocabul\u00e1rio controlado e as regras de sintaxe de uma linguagem de programa\u00e7\u00e3o espec\u00edfica para definir cada passo. Neste caso, as instru\u00e7\u00f5es devem ser escritas cautelosamente de acordo com a linguagem, no n\u00edvel de complexidade determinado pelo projeto desta. Abaixo mostramos poss\u00edveis formas de apresentar a m\u00e9dia aritm\u00e9tica de quatro n\u00fameros.</p> PythonCRust M\u00e9dia Aritm\u00e9tica<pre><code>notas = map(float, input().split())\nprint(f'A m\u00e9dia \u00e9 {sum(notas) / len(notas)}')\n</code></pre> M\u00e9dia Aritm\u00e9tica<pre><code>#include &lt;stdio.h&gt;\nint main(void) {\nfloat nota_1, nota_2, nota_3, nota_4;\nscanf(\"%f%f%f%f\", &amp;nota_1, &amp;nota_2, &amp;nota_3, &amp;nota_4);\nprintf(\"A m\u00e9dia \u00e9 %f\\n\", (nota_1 + nota_2 + nota_3 + nota_4) / 4);\nreturn 0;\n}\n</code></pre> M\u00e9dia Aritm\u00e9tica<pre><code>fn main() {\nuse std::io;\nlet mut entrada = String::new();\nio::stdin().read_line(&amp;mut entrada).expect(\"Erro ao ler a entrada\");\nlet notas: Vec&lt;f32&gt; = entrada.split_whitespace()\n.map(|x| x.parse().expect(\"Entrada n\u00e3o \u00e9 um n\u00famero!\"))\n.collect();\nlet media = notas.iter().sum::&lt;f32&gt;() / notas.len() as f32;\nprintln!(\"A m\u00e9dia \u00e9  {:?}\", media);\n}\n</code></pre> <p>Um algoritmo \u00e9 uma sequ\u00eancia de instru\u00e7\u00f5es bem definidas para realiza\u00e7\u00e3o uma tarefa. Algoritmos representados como linguagens de programa\u00e7\u00e3o podem ser fornecidos a computadores para execu\u00e7\u00e3o.</p> Llm <ul> <li>Explique o algoritmo PageRank.</li> <li>Qual o processo para resolu\u00e7\u00e3o de problemas computacionais?</li> <li>O que \u00e9 pseudoc\u00f3digo?</li> <li>Quais as etapas da programa\u00e7\u00e3o de computadores?</li> </ul> Fa\u00e7a um algoritmo em descri\u00e7\u00e3o narrativa para trocar uma l\u00e2mpada queimada de um abajur j\u00e1 tendo outra l\u00e2mpada nova dispon\u00edvel. <p>Trocar L\u00e2mpada<pre><code>    Desligue o abajur da tomada e retire a l\u00e2mpada queimada desenroscando-a em sentido anti-hor\u00e1rio (separe para descartar no local apropriado). Pegue a l\u00e2mpada nova e a coloque no abajur, rosqueando-a no sentido hor\u00e1rio. Ligue o abajur na tomada.\n</code></pre></p> Represente o algoritmo para c\u00e1lculo da m\u00e9dia aritm\u00e9tica de quatro n\u00fameros usando fluxograma. <pre><code>flowchart TD\n    I([In\u00edcio]) --&gt; L4[/Leia 4 notas/] --&gt; M[\"\u00b5 = notas \u00f7 4\"] --&gt; A[Apresente \u00b5] --&gt; T([Fim])\n</code></pre> Monte um fluxograma para um algoritmo que leia os tr\u00eas coeficientes de uma equa\u00e7\u00e3o de segundo grau e diga se as ra\u00edzes s\u00e3o reais ou complexas, e se s\u00e3o iguais. \\(ax^2+bx+c = 0 \\Rightarrow r = \\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\\) <pre><code>flowchart TD\n    I([In\u00edcio]) --&gt; L4[/Leia 4 notas/] --&gt; D[\"\u0394 = b\u00b2 - 4ac\"] --&gt; M0{\"\u0394 &lt; 0?\"} --&gt;|Sim| RC[/Ra\u00edzes complexas/] --&gt; F([Fim])\n    M0 --&gt; |N\u00e3o| RR[/Ra\u00edzes reais/] --&gt; D0{\"\u0394 = 0?\"} --&gt;|Sim| VR[/Ra\u00edzes iguais/] --&gt; F\n    D0 --&gt;|N\u00e3o| F\n</code></pre> Descreva, em pseudoc\u00f3digo, um algoritmo para ler dois n\u00fameros e apresentar o resultado da divis\u00e3o do primeiro pelo segundo. Divis\u00e3o<pre><code>In\u00edcio\n    Escreva \"Digite o numerador: \"\n    Leia [numerador].\n    Escreva \"Digite o denominador: \"\n    Leia o [denominador].\n    divis\u00e3o = numerador \u00f7 denominador\n    Escreva \"O resultado \u00e9 [divis\u00e3o].\"\nFim\n</code></pre> Descreva, em pseudoc\u00f3digo, o algoritmo para ler a idade de uma pessoa (em anos, meses e dias), e escrever a quantidade de horas vividas por ela. Assuma que todo ano tem 365 dias e todo m\u00eas tem 30 dias. Dias vividos<pre><code>In\u00edcio\n    Escreva \"Digite quantos anos voc\u00ea tem: \"\n    Leia [anos].\n    Escreva \"Digite quantos meses voc\u00ea tem: \"\n    Leia [meses].\n    Escreva \"Digite quantos dias voc\u00ea tem: \"\n    Leia [dias].\n    total = ((anos * 365) + (meses * 30) + dias) * 24\n    Escreva \"Voc\u00ea j\u00e1 viveu [total] horas.\"\nFim\n</code></pre> <ol> <li> <p>Thomas H. Cormen. Algorithms Unlocked. The MIT Press, 2013. ISBN 9780262518802. URL: https://mitpress.mit.edu/9780262518802/algorithms-unlocked/.\u00a0\u21a9</p> </li> <li> <p>Donald E. Knuth. The Art of Computer Programming, Vol. 1: Fundamental Algorithms. Addison-Wesley, Reading, Mass., third edition, 1997. ISBN 0201896834 9780201896831. URL: https://www-cs-faculty.stanford.edu/~knuth/taocp.html#vol1.\u00a0\u21a9</p> </li> </ol>"},{"location":"computadores/","title":"Computadores","text":"<p>Joe Sondow</p> <p>Um computador \u00e9 como um g\u00eanio travesso. Te d\u00e1 exatamente o que voc\u00ea pede dele, mas nem sempre o que voc\u00ea quer.</p> <p>Este cap\u00edtulo apresenta os conceitos b\u00e1sico envolvidos na concep\u00e7\u00e3o, constru\u00e7\u00e3o e uso do computador. Espera-se que o texto forne\u00e7a uma no\u00e7\u00e3o superficial de como a parte f\u00edsica e l\u00f3gica funcionam e servem de base para a constru\u00e7\u00e3o de programas de computadores.</p> <p>A humanidade \u00e9 engenhosa, e sempre buscou criar e aprimorar ferramentas para auxiliar nas realiza\u00e7\u00e3o de tarefas. Assim como o fogo e a roda, o computador \u00e9 uma ferramenta que revolucionou o mundo, e hoje em dia \u00e9 dif\u00edcil encontrar algum tipo de atividade que n\u00e3o seja (ou possa ser) auxiliada por esta m\u00e1quina que substituiu pessoas no esfor\u00e7o de processar dados e transform\u00e1-los em resultados. A hist\u00f3ria da computa\u00e7\u00e3o \u00e9 antiga e est\u00e1 entrela\u00e7ada com as hist\u00f3rias dos n\u00fameros, do hardware, de algoritmos e l\u00f3gica, e da programa\u00e7\u00e3o</p> <p>Os conhecimentos envolvidos em computa\u00e7\u00e3o s\u00e3o muito abrangentes, e s\u00e3o tantas as aplica\u00e7\u00f5es e possibilidades que criou-se uma nova \u00e1rea de conhecimento: a Ci\u00eancia da Computa\u00e7\u00e3o, que estuda a fundamenta\u00e7\u00e3o te\u00f3rica das constru\u00e7\u00f5es computacionais, bem como suas aplica\u00e7\u00f5es em dispositivos tecnol\u00f3gicos e sistemas de computa\u00e7\u00e3o1. Esta \u00e1rea est\u00e1 intrinsecamente associada a uma ferramenta: o computador que, de forma simplificada, \u00e9 uma m\u00e1quina que:</p> <ol> <li>realiza c\u00e1lculos [simples] rapidamente;</li> <li>lembra de [muitos] resultados.</li> </ol> <p>Um \"c\u00e1lculo\" \u00e9 a execu\u00e7\u00e3o de uma opera\u00e7\u00e3o primitiva pela m\u00e1quina, e um \"resultado\" \u00e9 uma informa\u00e7\u00e3o resultante desta opera\u00e7\u00e3o ou j\u00e1 conhecida. A computa\u00e7\u00e3o, portanto, lida basicamente com dois elementos, as informa\u00e7\u00f5es sendo manipuladas (dados) e as regras de manipula\u00e7\u00e3o delas (procedimentos)2. Ao descrever solu\u00e7\u00f5es como procedimentos que manipulam (corretamente) dados, pode-se usar o computador m\u00e1quina para resolver in\u00fameros problemas.</p> <p>A aplica\u00e7\u00e3o do pensamento computacional \u00e9 a forma mais interessante para sair da apresenta\u00e7\u00e3o de um problema at\u00e9 uma solu\u00e7\u00e3o que funcione corretamente em um computador. Este processo foca em dois elementos b\u00e1sicos: conhecimento descritivo (o que?) e, principalmente, procedural (como?).</p> <p>Por exemplo, considere o problema \"qual a raiz quadrada de um n\u00famero positivo \\(n\\)?\". \u00c9 necess\u00e1rio que um valor \\(n\\) seja fornecido, e deseja-se definir um procedimento que defina um outro valor \\(r\\) que atenda \u00e0 condi\u00e7\u00e3o \\(r^2 = n\\) (um conhecimento descritivo). Uma poss\u00edvel solu\u00e7\u00e3o \u00e9 descrita pelos passos \"M\u00e9todo Babil\u00f4nico\" abaixo.</p> M\u00e9todo Babil\u00f4nicoM\u00e9todo Babil\u00f4nico Computacional M\u00e9todo Babil\u00f4nico<pre><code>Inicie com um n\u00famero positivo arbitr\u00e1rio r (por exemplo, 1).\nEnquanto r\u00b2 \u2260 n:\n    Atualize o valor de r para metade de r + n/r.\n</code></pre> M\u00e9todo Babil\u00f4nico<pre><code>Inicie com um n\u00famero positivo arbitr\u00e1rio r (por exemplo, 1).\nEnquanto r\u00b2 n\u00e3o for suficientemente pr\u00f3ximo a n:\n    Atualize o valor de r para metade de r + n/r.\n</code></pre> <p>Esta solu\u00e7\u00e3o segue uma l\u00f3gica matem\u00e1tica correta, mas n\u00e3o funcionaria em um computador para qualquer valor de \\(n\\) pois a m\u00e1quina tem limita\u00e7\u00f5es que precisam ser consideradas! Estas ser\u00e3o discutidas ao longo do texto, mas uma solu\u00e7\u00e3o que vence uma delas \u00e9 apresentada em \"M\u00e9todo Babil\u00f4nico Computacional\". Infelizmente, esta segunda abordagem tamb\u00e9m n\u00e3o produz resultados exatos para qualquer valor de \\(n\\). Considerando \\(n = 144\\), uma estimativa inicial \\(r = 1\\) e que \"suficientemente pr\u00f3ximo\" signifique que \\(|n - r^2| \\leq 0,5\\), a aplica\u00e7\u00e3o das instru\u00e7\u00f5es acima resultam na constru\u00e7\u00e3o da seguinte sequ\u00eancia de valores para \\(r\\): 1, 72.5, 37.24, 20.55, 13.8 e, finalmente, 12.1.</p> <p>Independentemente, uma descri\u00e7\u00e3o precisa dos passos permite que o computador realize o processo mec\u00e2nico para chegar \u00e0 solu\u00e7\u00e3o aceit\u00e1vel. Para resolver um problema diferente, basta fornecer um grupo diferente de instru\u00e7\u00f5es!</p> <p>Warning</p> <p>O computador interpreta as instru\u00e7\u00f5es no sentido de receb\u00ea-las em uma representa\u00e7\u00e3o espec\u00edfica e traduzi-las em sua opera\u00e7\u00f5es primitivas para execu\u00e7\u00e3o, n\u00e3o no sentido de dar-lhes sentido para obter o resultado desejado. Ele faz o que voc\u00ea manda, n\u00e3o o que voc\u00ea quer.</p> <p>Entender mais sobre esta m\u00e1quina e como ela funciona \u00e9 essencial para us\u00e1-la na resolu\u00e7\u00e3o de problemas. O computador, al\u00e9m de processar e armazenar os dados, tamb\u00e9m precisa moviment\u00e1-los entre os dispositivos e controlar toda essa manipula\u00e7\u00e3o. Para tanto, \u00e9 preciso que diversos componentes el\u00e9tricos, eletr\u00f4nicos e eletromec\u00e2nicos (hardware) trabalhem em conjunto para realizar os processos definidos no algoritmo (software).</p>"},{"location":"computadores/#arquitetura-de-computadores","title":"Arquitetura de Computadores","text":"<p>A arquitetura do computador busca projetar a m\u00e1quina de tal forma a maximizar desempenho e efici\u00eancia energ\u00e9tica dentro das restri\u00e7\u00f5es de custo, pot\u00eancia e disponibilidade existentes3. A fun\u00e7\u00e3o principal do computador \u00e9 realizar as computa\u00e7\u00f5es, ou seja, processar os dados. Isso \u00e9 feito com as opera\u00e7\u00f5es b\u00e1sicas de l\u00f3gica e aritm\u00e9tica que s\u00e3o constru\u00eddas na m\u00e1quina. Para viabilizar estas opera\u00e7\u00f5es, \u00e9 preciso armazenar os dados, mov\u00ea-los entre os dispositivos de armazenagem e processamento e gerenciar esta movimenta\u00e7\u00e3o com o processamento.</p> <p>Na arquitetura mais comum, as instru\u00e7\u00f5es s\u00e3o vistas como informa\u00e7\u00f5es que armazenadas, ou seja, conhecimento descritivo, e s\u00e3o tratadas como dados que o computador processa. Este modelo de \"computador de programa armazenado\", em que as instru\u00e7\u00f5es e os dados existem em um mesmo meio f\u00edsico, \u00e9 conhecido como Arquitetura de von Neumann4, e \u00e9 a forma mais comum dos computadores modernos. Nela, a solu\u00e7\u00e3o de um problema \u00e9 obtida por um ciclo de execu\u00e7\u00e3o simples: busca (a pr\u00f3xima instru\u00e7\u00e3o), decodifica\u00e7\u00e3o (em instru\u00e7\u00f5es primitivas) e execu\u00e7\u00e3o (das primitivas realizando a computa\u00e7\u00e3o).</p> <p></p> <p>Este modelo representa os principais componentes necess\u00e1rios para o processo de ler a instru\u00e7\u00e3o, interpret\u00e1-la e execut\u00e1-la. A mem\u00f3ria armazena as instru\u00e7\u00f5es (conhecimento procedural) e os resultados intermedi\u00e1rios (conhecimento descritivo). Novos dados podem ser fornecidos ao computador por algum dispositivo de entrada ou obtidos dele por um dispositivo de sa\u00edda. O processador gerencia quais instru\u00e7\u00f5es devem ser realizadas e suas execu\u00e7\u00f5es, al\u00e9m de movimentar as informa\u00e7\u00f5es entre os componentes. Para isso, tem dispositivos que realizam opera\u00e7\u00f5es de aritm\u00e9tica e l\u00f3gica, testes simples, e manipula\u00e7\u00e3o de dados.</p> <p>A implementa\u00e7\u00e3o f\u00edsica deste modelo necessita de uma parte f\u00edsica que realiza a tarefa, e de uma parte l\u00f3gica que define como realiz\u00e1-la. Apesar de nos preocuparmos mais com a parte l\u00f3gica neste livro, ambas s\u00e3o essenciais para o bom funcionamento.</p>"},{"location":"computadores/#hardware","title":"Hardware","text":"<p>O hardware \u00e9 um conjunto de componentes e equipamentos que comp\u00f5em um sistema computacional, que seguem a arquitetura von Neumann. Os componentes f\u00edsicos t\u00eam diferentes prop\u00f3sitos.</p> <p> </p> <ul> <li>\u2462 Unidade Central de Processamento (UCP) \u00e9 o dispositivo que interpreta e executa e instru\u00e7\u00f5es, l\u00ea e escreve a mem\u00f3ria. Seus componentes b\u00e1sicos s\u00e3o a UC (que determina quais opera\u00e7\u00f5es ser\u00e3o realizadas e em que ordem) e a ULA (que realiza opera\u00e7\u00f5es aritm\u00e9ticas e l\u00f3gicas). Os registradores, que armazenam os dados sendo processados no momento, tamb\u00e9m podem ser considerado parte da UCP, mas s\u00e3o conceitualmente parte da mem\u00f3ria. O desempenho da UCP era ligado a sua velocidade, mas certos limites j\u00e1 foram alcan\u00e7ados e, atualmente, os esfor\u00e7os s\u00e3o direcionados a outras formas de melhoria.</li> <li>\u2463, \u2467 mem\u00f3ria \u00e9 o dispositivo que permite armazenar dados em um conjunto ordenado de bits. A armazenagem pode ser vol\u00e1til (perde seus dados com aus\u00eancia de energia) ou n\u00e3o vol\u00e1teis. Al\u00e9m disso, h\u00e1 certa hierarquia de tipos, pois o custo \u00e9 inversamente proporcional a velocidade de acesso. A chamada mem\u00f3ria principal cont\u00e9m os dados sendo manipulados na tarefa em execu\u00e7\u00e3o (na mem\u00f3ria vol\u00e1til), portanto \u00e9 mais r\u00e1pida e intermedia o acesso aos dados da mem\u00f3ria secund\u00e1ria. Esta serve para armazenamento permanente de dados, tem maior capacidade mas desempenho inferior. A caracter\u00edstica mais interessante da mem\u00f3ria principal \u00e9 o acesso aleat\u00f3rio, em que posi\u00e7\u00f5es espec\u00edficas de mem\u00f3ria s\u00e3o acessadas diretamente, utilizando uma l\u00f3gica de endere\u00e7amento. Isto, e a velocidade do acesso, contrastam com a mem\u00f3ria secund\u00e1ria.</li> <li> <p>\u2460, \u2466, \u2468 e \u2469 Entrada/Sa\u00edda os dispositivos de entrada e sa\u00edda de dados (E/S ou I/O) permitem a comunica\u00e7\u00e3o com o computador, de modo que ele possa receber dados para realizar uma tarefa, e fornecer os resultados desta. Existem diversas formas de transmitir os dados:</p> <ul> <li>Entrada: teclado, mouse, microfone, scanner, leitor de c\u00f3digo de barras, c\u00e2mera, joystick, etc.;</li> <li>Sa\u00edda: monitor, caixas de som, impressora, etc.;</li> <li>E/S: disco r\u00edgido, monitor sens\u00edvel a toques, pendrive, etc.</li> </ul> </li> </ul> <p>Al\u00e9m destes componentes \"b\u00e1sicos\" da arquitetura von Neumann, diversos outros s\u00e3o necess\u00e1rios.</p> <ul> <li>\u2461 placa m\u00e3e conecta os componentes do computador de modo que possam funcionar em conjunto, possibilitando a comunica\u00e7\u00e3o entre eles e a distribui\u00e7\u00e3o de energia.</li> <li>\u2464 placas de expans\u00e3o que possibilitam o uso de outros componentes perif\u00e9ricos, ampliando as aplica\u00e7\u00f5es.</li> <li>\u2465 fonte de alimenta\u00e7\u00e3o que regula a distribui\u00e7\u00e3o de energia para os componentes.</li> <li>barramento \u00e9 o sistema de comunica\u00e7\u00e3o que transfere dados entre os componentes do computador. A taxa de transfer\u00eancia do barramento \u00e9 o que define seu desempenho. Barramentos: processador, cache, mem\u00f3ria, dispositivos de entrada/sa\u00edda, dados.</li> <li>mainFrame/supercomputador s\u00e3o computadores grande porte, geralmente dedicados a aplica\u00e7\u00f5es espec\u00edficas que demandam o processamento de grandes volumes de informa\u00e7\u00e3o.</li> <li>a \"nuvem\" \u00e9 o uso de computadores e servidores compartilhados e interligados por meio da Internet, seguindo o princ\u00edpio da computa\u00e7\u00e3o em grade.</li> </ul> <p>O funcionamento de um computador ocorre pela manipula\u00e7\u00e3o e comunica\u00e7\u00e3o de sinais el\u00e9tricos entre seus componentes, como um processo f\u00edsico, sendo os sinais mais simples s\u00e3o os sinais \"ligado\" e \"desligado\"5. Esse estado bin\u00e1rio de um sinal pode ser representado por um binary digit (um bit), um valor que pode ser um de dois estados distintos e mutuamente exclusivos6: <code>0</code> (desligado) ou <code>1</code> (ligado). Os conjuntos de bits determinam as informa\u00e7\u00f5es armazenadas, inclusive os programas que determinam o que a m\u00e1quina deve fazer.</p>"},{"location":"computadores/#software","title":"Software","text":"<p>O software \u00e9 a parte l\u00f3gica do sistema computacional, que define quais instru\u00e7\u00f5es devem ser executadas pelo hardware. Pode ser dividido em dois tipos, programas de sistema que possibilitam a intera\u00e7\u00e3o com o hardware (computador e perif\u00e9ricos) e fornecem uma plataforma para execu\u00e7\u00e3o das aplica\u00e7\u00f5es, que realizam tarefas mais espec\u00edficas como edi\u00e7\u00e3o de documentos, organiza\u00e7\u00e3o de dados, entretenimento, educacional, manipula\u00e7\u00e3o de m\u00eddia, e outros.</p> Programas de Sistema <p>O sistema operacional \u00e9 o conjunto de programas que gerencia o hardware e fornece servi\u00e7os comuns \u00e0s aplica\u00e7\u00f5es. Podem ser de tempo-real, multi-usu\u00e1rio, multi-tarefas, embarcado, entre outros. Possibilita a comunica\u00e7\u00e3o com os componentes de n\u00facleo, que controla execu\u00e7\u00e3o, interrup\u00e7\u00f5es, gerenciamento de mem\u00f3ria [virtual], acesso a disco e arquivos, comunica\u00e7\u00e3o com dispositivos, etc., bem como de comunica\u00e7\u00e3o, seguran\u00e7a, interface gr\u00e1fica, entre outros.</p> <p>Os sistemas mais conhecidos s\u00e3o: Unix (BSD, GNU-Linux, OS X), Microsoft Windows, Plan 9, Android, etc. \u00c9 poss\u00edvel ter uma ideia da utiliza\u00e7\u00e3o de cada sistema por sua fatia de mercado. Atualmente, o Windows domina o mercado de desktops, e o de dispositivos m\u00f3veis \u00e9 dividido entre Android e iOS. Mas a computa\u00e7\u00e3o de alto desempenho \u00e9 praticamente toda em Unix.</p> <p>Os utilit\u00e1rios s\u00e3o os programas que auxiliam a analisar e configurar o computador, como an\u00e1lise/manuten\u00e7\u00e3o de disco, an\u00e1lise de mem\u00f3ria, anti-v\u00edrus, armazenamento de dados, cifragem, compress\u00e3o, conectividade com a rede, c\u00f3pia de seguran\u00e7a, gerenciador de arquivos, monitora\u00e7\u00e3o do processador, sincroniza\u00e7\u00e3o de dados/arquivos, entre muitos outros. Alguns exemplos s\u00e3o an\u00e1lise/manuten\u00e7\u00e3o de disco, an\u00e1lise de mem\u00f3ria, anti-v\u00edrus, armazenamento de dados, cifragem, compress\u00e3o, conectividade com a rede, c\u00f3pia de seguran\u00e7a, gerenciador de arquivos, monitora\u00e7\u00e3o do processador, sincroniza\u00e7\u00e3o de dados/arquivos.</p> <p>Os controladores de dispositivos, tamb\u00e9m conhecidos como drivers de dispositivos, s\u00e3o os programas que gerenciam um hardware espec\u00edfico do computador, como barramento, impressora, m\u00e1quinas digitais, placa de rede/\u00e1udio/v\u00eddeo/aquisi\u00e7\u00e3o de sinais, scanner, smartphones, etc.</p> <p>As interfaces com usu\u00e1rio s\u00e3o programas que interagem com o usu\u00e1rio, geralmente divididos em fun\u00e7\u00e3o do uso via linha de comando ou interface gr\u00e1fica.</p> <p>Os programas de desenvolvimento auxiliam o desenvolvimento de programas, como compiladores, interpretadores, IDEs, montadores, depuradores, etc.</p> Aplica\u00e7\u00f5es <p>S\u00e3o os programas com fins espec\u00edficos, como navegadores, programa para escrit\u00f3rio, entretenimento, e muitos, muitos mais.</p> <p>As aplica\u00e7\u00f5es de maior interesse neste contexto s\u00e3o as de desenvolvimento de software. Durante o aprendizado, vale a pena entender como usar um editor de texto simples e a linha de comando, de modo a consolidar os conhecimentos e habilidades pr\u00e1ticas de programa\u00e7\u00e3o. Entretanto, certas IDEs s\u00e3o de grande valia no processo. Por exemplo, o Thonny.</p> <p>Esta IDE foi criada com o foco no aprendizado, com interface simples e intuitiva, disponibilizando uma s\u00e9rie de informa\u00e7\u00f5es como conte\u00fado de vari\u00e1veis e, principalmente, de depura\u00e7\u00e3o integrada. Isso permite que se acompanhe a execu\u00e7\u00e3o de cada instru\u00e7\u00e3o, passo a passo, visualiza\u00e7\u00e3o de chamadas de fun\u00e7\u00f5es.</p> Resumo <p></p> Chatbot <ul> <li>Explique a arquitetura Von Neumann.</li> <li>O que \u00e9 hardware em um computador?</li> <li>O que \u00e9 software?</li> <li>Explique os n\u00edveis de mem\u00f3ria de um computador.</li> <li>Explique as camadas de software de um computador.</li> <li>Explique o conceito de linguagem de programa\u00e7\u00e3o.</li> <li>Qual a diferen\u00e7a entre compilador e interpretador?</li> </ul> <p>Algumas op\u00e7\u00f5es s\u00e3o ChatGPT, Gemini, Claude e Llama. Estes modelos podem cometer erros! Verifique as informa\u00e7\u00f5es em fontes confi\u00e1veis.</p> Exerc\u00edcios Descreva os componentes f\u00edsicos de um computador e suas funcionalidades. <p>A unidade central de processamento \u00e9 o dispositivo que interpreta e executa e instru\u00e7\u00f5es, l\u00ea e escreve a mem\u00f3ria, tendo como parte integrante os registradores que armazenam os dados sendo processados no momento. Mem\u00f3ria permite armazenar dados em um conjunto ordenado de bits.</p> <p>Os dispositivos de entrada e sa\u00edda de dados permitem que humanos e outras m\u00e1quinas se comunica\u00e7\u00e3o com o computador. Exemplos de dispositivos de entrada s\u00e3o: teclado, mouse, microfone, scanner, leitor de c\u00f3digo de barras, c\u00e2mera, joystick, etc. Exemplos de sa\u00edda s\u00e3o: monitor, caixas de som, impressora, etc. H\u00e1 dispositivos que fazem ambas: disco r\u00edgido, monitor sens\u00edvel a toques, pendrive, etc.</p> <p>O barramento \u00e9 o sistema de comunica\u00e7\u00e3o que transfere dados entre os componentes do computador (a taxa de transfer\u00eancia do barramento \u00e9 o que define o desempenho da m\u00e1quina). A fonte de alimenta\u00e7\u00e3o regula a distribui\u00e7\u00e3o de energia para os componentes. A placa m\u00e3e conecta os componentes do computador ao barramento e \u00e0 fonte.</p> H\u00e1 uma hierarquia entre os diferentes tipos de mem\u00f3ria, descreva-a. <p>A classifica\u00e7\u00e3o se d\u00e1 com base em dois conceitos: capacidade de armazenamento e velocidade de acesso. As mem\u00f3rias mais r\u00e1pidas t\u00eam menor capacidade, e vice-versa. O primeiro n\u00edvel \u00e9 a mem\u00f3ria interna, composta pelos registradores, pequenas unidades extremamente r\u00e1pidas no processador, e pela cache que serve para intermediar a comunica\u00e7\u00e3o ente os registradores e a mem\u00f3ria principal. O segundo n\u00edvel \u00e9 mem\u00f3ria RAM, que \u00e9 diretamente ligada \u00e0 UCP para leitura/escrita e j\u00e1 detalhada no texto.</p> <p>O pr\u00f3ximo n\u00edvel \u00e9 a mem\u00f3ria secund\u00e1ria (n\u00e3o vol\u00e1til), que \u00e9 acessada indiretamente pela UCP uma vez que seu conte\u00fado \u00e9 transmitido pelo sistema operacional e componentes de comunica\u00e7\u00e3o para a mem\u00f3ria principal. A capacidade tende a ser significativamente maior que da prim\u00e1ria, e exemplos de dispositivos assim s\u00e3o CDs, SSDs, etc. O \u00faltimo n\u00edvel \u00e9 a mem\u00f3ria terci\u00e1ria, que envolve a manipula\u00e7\u00e3o de informa\u00e7\u00f5es que s\u00e3o muito raramente utilizadas, tanto que podem ser armazenadas de forma isolada, necessitando a reconex\u00e3o f\u00edsica \u00e0 m\u00e1quina (para copiar os dados para a mem\u00f3ria secund\u00e1ria).</p> <ol> <li> <p>SBC. Curr\u00edculo de Refer\u00eancia da SBC para Cursos de Gradua\u00e7\u00e3o em Bacharelado em Ci\u00eancia da Computa\u00e7\u00e3o e Engenharia de Computa\u00e7\u00e3o. URL: http://www.sbc.org.br/documentos-da-sbc/category/131-curriculos-de-referencia.\u00a0\u21a9</p> </li> <li> <p>Harold Abelson, Gerald Jay Sussman, and Julie Sussman. Structure and Interpretation of Computer Programs. MIT Press, Cambridge, MA, USA, 1985. ISBN 0262010771.\u00a0\u21a9</p> </li> <li> <p>John L. Hennessy and David A. Patterson. Computer Architecture, Fifth Edition: A Quantitative Approach. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 5th edition, 2011. ISBN 012383872X.\u00a0\u21a9</p> </li> <li> <p>M.D. Godfrey and D.F. Hendry. The computer as von Neumann planned it. IEEE Annals of the History of Computing, 15(1):11\u201321, 1993. doi:10.1109/85.194088.\u00a0\u21a9</p> </li> <li> <p>David A. Patterson and John L. Hennessy. Computer Organization and Design. Morgan Kaufmann Publishers, 2nd edition, 1998. ISBN 15-586-0428-6.\u00a0\u21a9</p> </li> <li> <p>Aaron M Tenenbaum, Yedidyah Langsam, and Moshe Augenstein. Estruturas de dados usando C. Pearson Makron Books, S\u00e3o Paulo (SP), 1995. ISBN 8534603480 : 9788534603485.\u00a0\u21a9</p> </li> </ol>"},{"location":"estruturas_de_dados/","title":"Estruturas de Dados","text":"<p>David Jones</p> <p>Acerte as estruturas de dados primeiro, e o resto do programa se escrever\u00e1 sozinho.</p> <p></p>"},{"location":"estruturas_de_dados/#homogeneas","title":"Homog\u00eaneas","text":""},{"location":"estruturas_de_dados/#heterogeneas","title":"Heterog\u00eaneasResumoExerc\u00edcios","text":"Llm"},{"location":"pensamento_computacional/","title":"Pensamento Computacional","text":"<p>Albert Einstein</p> <p>N\u00e3o podemos resolver um problema usando o mesmo tipo de pensamento que usamos quando os criamos.</p> <p>Este cap\u00edtulo apresenta as principais ideias do pensamento computacional e como elas podem ser aplicadas na resolu\u00e7\u00e3o de problemas. Ao final do texto, espera-se que se tenha uma no\u00e7\u00e3o clara do que significa cada uma delas e aplic\u00e1-las em problemas simples.</p> <p>No dia a dia \u00e9 muito comum lidar com algum problema inesperado cuja solu\u00e7\u00e3o \u00e9 desconhecida. Nesse caso, uma abordagem comum \u00e9 considerar os diversos aspectos do problema para tentar reconhecer as a\u00e7\u00f5es necess\u00e1rias para resolver cada, organizar essas a\u00e7\u00f5es em uma ordem que fa\u00e7a sentido de modo que se tenha uma plano para resolv\u00ea-lo. Por exemplo, se estiver em uma cidade desconhecida e quiser chegar a casa de um parente, voc\u00ea pode obter um mapa, identificar a sua posi\u00e7\u00e3o e a rua onde ele mora e, com isso, definir uma sequ\u00eancia de movimenta\u00e7\u00f5es para sair da origem e chegar ao destino. A melhor parte \u00e9 que essa rota deve servir para qualquer pessoa que queira ir desse ponto de partida para o mesmo local de chegada.</p> <p>Esse fluxo de atividades, de se ter um objetivo em mente, ponderar sobre como atingi-lo para, ent\u00e3o, elaborar uma sequ\u00eancia de passos que o atinjam \u00e9 uma situa\u00e7\u00e3o cotidiana. Pode-se considerar que chegar ao objetivo \u00e9 um problema a ser resolvido, e que os passos adequados comp\u00f5em sua solu\u00e7\u00e3o. Uma vez determinada a solu\u00e7\u00e3o para um problema espec\u00edfico, espera-se que ela funcione para toda inst\u00e2ncia do problema. Por exemplo, uma receita \u00e9 uma solu\u00e7\u00e3o para se obter um bolo, e toda vez que se quiser o bolo, bastaria seguir a receita. Esta solu\u00e7\u00e3o resolve at\u00e9 o problema de outras pessoas! Desde que elas queiram este mesmo bolo...</p> <p>A obten\u00e7\u00e3o de uma solu\u00e7\u00e3o pode ser um processo criativo complexo, com etapas de elabora\u00e7\u00e3o, implementa\u00e7\u00e3o e verifica\u00e7\u00e3o. Quando funciona, este processo pode ser muito satisfat\u00f3rio, afinal quem n\u00e3o gosta de bolo? Claro, esta ideia tamb\u00e9m se aplica a outros problemas. \u00c9 poss\u00edvel definir os passos para montar um m\u00f3vel (manual de instru\u00e7\u00f5es), para conseguir lidar com a demanda de clientes em uma institui\u00e7\u00e3o (filas e prioridades), e muito mais.</p> <p>Um algoritmo pode ser considerado como uma descri\u00e7\u00e3o dos passos necess\u00e1rios para resolver o problema, ou seja, representa uma solu\u00e7\u00e3o que poderia ser executada por um agente qualquer. O computador \u00e9 uma m\u00e1quina capaz de interpretar e executar certas instru\u00e7\u00f5es, podendo ser o agente que executa o algoritmo, desde que este seja representado com as instru\u00e7\u00f5es espec\u00edficas que o computador entenda. Assim, para que a m\u00e1quina resolva nossos problemas, devemos guiar o processo de elabora\u00e7\u00e3o de solu\u00e7\u00f5es como uma atividade de cria\u00e7\u00e3o de um algoritmo computacional, que \u00e9 a descri\u00e7\u00e3o precisa de um procedimento para realizar uma tarefa, de modo que um computador possa execut\u00e1-la1.</p> <p>O pensamento computacional \u00e9 o processo envolvido na formula\u00e7\u00e3o de problemas de modo que suas solu\u00e7\u00f5es possam ser representadas como etapas computacionais e algoritmos2. S\u00e3o os processos mentais envolvidos na descri\u00e7\u00e3o de um problema de tal forma que a solu\u00e7\u00e3o possa ser executada por uma pessoa ou por um computador3. Como a computa\u00e7\u00e3o tem permeado cada vez mais nossa vida, e a no\u00e7\u00e3o do pensamento computacional tem sido incorporada como conhecimento desej\u00e1vel para uma pessoa. Uma proposta \u00e9 que o aluno se torne um \"pensador computacional\"4 e, neste caso, espera-se que ele aprenda a:</p> <ul> <li>desenvolver e usar estrat\u00e9gias para resolver problemas com tecnologia;</li> <li>formular problemas para serem resolvidos com a ajuda da tecnologia como coleta e an\u00e1lise de dados, abstra\u00e7\u00e3o e aplica\u00e7\u00e3o de algoritmos;</li> <li>decompor problemas, extrair as informa\u00e7\u00f5es relevantes e conseguir produzir modelos que facilitem a resolu\u00e7\u00e3o d problemas;</li> <li>entender como a automa\u00e7\u00e3o funciona junto ao pensamento algor\u00edtmico para juntar etapas manuais em solu\u00e7\u00f5es automatizadas.</li> </ul> <p>Essencialmente, o pensamento computacional envolve habilidades de converter problemas reais, que s\u00e3o complexos, confusos e mal definidos, em algo que um aut\u00f4mato sem intelig\u00eancia (o computador) consiga resolver sem aux\u00edlio de algu\u00e9m5. H\u00e1 muitos conceitos envolvidos6, como coleta e an\u00e1lise de dados, representa\u00e7\u00e3o de dados e paraleliza\u00e7\u00e3o - vale a pena procurar saber mais sobre eles! Os principais conceitos do processo s\u00e3o apresentados a seguir.</p>"},{"location":"pensamento_computacional/#decomposicao","title":"Decomposi\u00e7\u00e3o","text":"<p>A decomposi\u00e7\u00e3o \u00e9 o processo de separar o problema em partes, ou subproblemas, de modo que cada um deles seja menor e mais simples - portanto mais f\u00e1cil de ser resolvido. Esse processo pode ser repetido at\u00e9 que se tenha um problema simples o suficiente para elaborar uma solu\u00e7\u00e3o. Depois, basta juntar as solu\u00e7\u00f5es de cada subproblema de forma coesa para obter a solu\u00e7\u00e3o do problema original.</p> <p>Por exemplo, \u00e9 mais f\u00e1cil entender isoladamente o funcionamento de cada um dos diversos sistemas do corpo humano para depois analisar como eles trabalham em conjunto do que tentar entender o seu funcionamento considerando todos os \u00f3rg\u00e3os em a\u00e7\u00e3o de uma s\u00f3 vez. Tamb\u00e9m \u00e9 mais f\u00e1cil organizar sua cole\u00e7\u00e3o de m\u00fasicas se ela for reestruturada em g\u00eaneros musicais - e a organiza\u00e7\u00e3o de cada g\u00eanero \u00e9 mais simples ao lidar com um estilo de cada vez.</p> <p>O primeiro passo para decompor um problema \u00e9 entend\u00ea-lo corretamente de modo a identificar e descrever os processos (e subproblemas) envolvidos na sua resolu\u00e7\u00e3o. Com essa informa\u00e7\u00e3o, \u00e9 poss\u00edvel particionar os processos (e subproblemas) em passos distintos, que ent\u00e3o s\u00e3o organizados de forma estruturada para que possam ser executados.</p> <p>Considere a seguinte equa\u00e7\u00e3o: \\(213 \\times 21\\). A multiplica\u00e7\u00e3o \u00e9 uma repeti\u00e7\u00e3o de somas, ent\u00e3o o resultado pode ser obtido somando o primeiro 21 vezes (ou o segundo 213 vezes). Entendendo como o sistema de numera\u00e7\u00e3o funciona, pode-se decompor esta opera\u00e7\u00e3o complexa como um conjunto de opera\u00e7\u00f5es de soma mais simples, basta considerar que 21 \u00e9, na verdade, a soma de 20 com 1. Buscando um processo mais simples, podemos considerar ainda que \\(20 = 10 + 10\\), e resolver a multiplica\u00e7\u00e3o da seguinte forma:</p> \\[ \\begin{align} 21 \\times 213 &amp; = (20 + 1) \\times 213 \\\\ &amp; = (20 \\times 213) + (1 \\times 213) \\\\ &amp; = ((10 + 10) \\times 213) + (1 \\times 213) \\\\ &amp; = ((10 \\times 213) + (10 \\times 213)) + (1 \\times 213) \\\\ &amp; = (2130 + 2130) + 213 \\\\ &amp; = 4260 + 213 \\\\ &amp; = 4473 \\end{align} \\] <p>Apesar da impress\u00e3o de que esta decomposi\u00e7\u00e3o cria um processo mais longo, as tarefas que s\u00e3o efetivamente resolvidas s\u00e3o bem mais simples que a tarefa original - \u00e9 mais r\u00e1pido lidar com estas muitas tarefas f\u00e1ceis que lidar com uma tarefa complexa.</p>"},{"location":"pensamento_computacional/#reconhecimento-de-padroes","title":"Reconhecimento de Padr\u00f5es","text":"<p>Se voc\u00ea observa seguinte sequ\u00eancia: \\(2, 4, 6, 8, 10, 12, 14, 16, 18\\) e \\(20\\), pode reconhecer o padr\u00e3o que todos os n\u00fameros s\u00e3o pares e aumentam de 2 em 2 - portanto poderia prever que o pr\u00f3ximo n\u00famero seria \\(22\\). De modo similar, ao separar o problema em partes, \u00e9 comum perceber que h\u00e1 similaridades entre elas. Reconhecer estes padr\u00f5es permite que se crie abordagens mais gen\u00e9ricas que se adequem \u00e0 uma classe de problemas, e n\u00e3o a somente uma ocorr\u00eancia dele.</p> <p>Por exemplo, considere as seguintes retas em um plano cartesiano que descrevem fen\u00f4menos f\u00edsicos observados.</p> <p></p> <p>Embora claramente diferentes, elas tamb\u00e9m t\u00eam similaridades. O comportamento de cada uma pode ser descrito de forma gen\u00e9rica pela equa\u00e7\u00e3o \\(y = a\\cdot{x} + b\\). As implica\u00e7\u00f5es (e aplica\u00e7\u00f5es) disso s\u00e3o muito interessantes, esta abordagem simples pode ser utilizada para qualquer inst\u00e2ncia do problema!</p> <p>Considere o problema de definir um procedimento para desenhar um um tri\u00e2ngulo equil\u00e1tero. Sabe-se que ele tem os 3 \u00e2ngulos internos iguais a 60\u00b0 e as 3 linhas com o mesmo comprimento. Se o \u00e2ngulo interno \u00e9 de 60\u00b0, o \u00e2ngulo externo \u00e9 de 120\u00b0, e torna-se relativamente simples definir um algoritmo que desenhe uma destas formas. De modo similar, um quadrado tem os 4 \u00e2ngulos internos iguais a 90\u00b0 e as 4 linhas com o mesmo comprimento; sendo simples adaptar o algoritmo anterior para desenhar um quadrado. Desenvolvendo esta abordagem para um pent\u00e1gono regular, \u00e9 poss\u00edvel perceber que as solu\u00e7\u00f5es s\u00e3o muito similares... A solu\u00e7\u00e3o proposta constr\u00f3i o desenho de modo que cada linha continua a partir do fim da linha anterior, usando o \u00e2ngulo externo do pol\u00edgono para a rota\u00e7\u00e3o.</p> Propriedade dos \u00e2ngulos interno/externo. Tri\u00e2nguloQuadradoPent\u00e1gono <pre><code>Desenhe uma linha de comprimento L.\nGire a caneta em 120\u00b0 no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em 120\u00b0 no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\n</code></pre> <pre><code>Desenhe uma linha de comprimento L.\nGire a caneta em 90\u00b0 no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em 90\u00b0 no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em 90\u00b0 no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\n</code></pre> <pre><code>Desenhe uma linha de comprimento L.\nGire a caneta em 118\u00b0 no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em 118\u00b0 no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em 118\u00b0 no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\nGire a caneta em 118\u00b0 no sentido anti-hor\u00e1rio.\nDesenhe uma linha de comprimento L.\n</code></pre> <p>Nos algoritmos, os \u00e2ngulos e a quantidade de linhas s\u00e3o diferentes, mas tamb\u00e9m \u00e9 poss\u00edvel reconhecer dois padr\u00f5es nos processos:</p> <ol> <li>Para um pol\u00edgono regular de \\(n\\) lados, tem-se \\(n\\) linhas desenhadas.</li> <li>Cada linha forma um \u00e2ngulo externo de \\(^{360\u00b0}/_n\\) com outra linha.</li> </ol> <p>Desta forma, \u00e9 poss\u00edvel ajustar os procedimentos de desenho e angula\u00e7\u00e3o das linhas para formar tri\u00e2ngulos, quadrados e pent\u00e1gonos apenas em fun\u00e7\u00e3o da quantidade de lados destas formas. Melhor ainda, pode-se determinar uma solu\u00e7\u00e3o gen\u00e9rica que atende qualquer pol\u00edgono regular.</p> Tri\u00e2nguloQuadradoPent\u00e1gonoPol\u00edgonoPython + Turtle Tri\u00e2ngulo Equil\u00e1tero<pre><code>\u00e2ngulo_externo = 360 / 3\n\n# 3 repeti\u00e7\u00f5es\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n</code></pre> Ret\u00e2ngulo Regular<pre><code>\u00e2ngulo_externo = 360 / 4\n\n# 4 repeti\u00e7\u00f5es\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n</code></pre> Pent\u00e1gono Regular<pre><code>\u00e2ngulo_externo = 360 / 5\n\n# 5 repeti\u00e7\u00f5es\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n\nDesenhe uma linha de comprimento L.\nGire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n</code></pre> Pol\u00edgono Regular<pre><code>\u00e2ngulo_externo = 360 / n\u00famero_de_lados\n\nRepita n\u00famero_de_lados vezes:\n    Desenhe uma linha de comprimento L.\n    Gire a caneta em \u00e2ngulo_externo graus no sentido anti-hor\u00e1rio.\n</code></pre> Pol\u00edgono Regular<pre><code>angulo_externo = 360 / num_lados\nfor _ in range(num_lados):\nlinha(comprimento)\nesquerda(angulo_externo)\n</code></pre>"},{"location":"pensamento_computacional/#abstracao","title":"Abstra\u00e7\u00e3o","text":"<p>Abstrair \u00e9 o processo de identificar um conjunto de caracter\u00edsticas invariantes fundamentais a algo7. \u00c9 reconhecer similaridades entre objetos ou situa\u00e7\u00f5es de um problema e focar apenas nelas, ignorando as especificidades para facilitar a forma como tratar o problema8, escondendo informa\u00e7\u00f5es que n\u00e3o sejam necess\u00e1rias9,</p> <p>Por exemplo, o problema de cultivar uma rosa vermelha. Como buscamos o processo de mant\u00ea-la saud\u00e1vel, podemos assumir que este processo independe da cor e, portanto, abstrair este detalhe para cultivar uma rosa. Se for uma esp\u00e9cie de rosa mais robusta, podemos abstrair novamente e simplificar o problema para o cultivo de uma flor. Dependendo da esp\u00e9cie, talvez possamos dar um passo al\u00e9m e reduzir o problema para \"como cultivar uma planta?\" (dar mais um passo e considerar como manter um ser vivo \u00e9 poss\u00edvel, mas excessivo neste contexto).</p> <p>A abstra\u00e7\u00e3o \u00e9 um processo inerente no contexto de pensamento computacional, pois \u00e9 preciso transformar o problema e sua solu\u00e7\u00e3o em representa\u00e7\u00f5es abstratas em um programa de computador. Por exemplo, podemos ter todos os in\u00fameros detalhes de uma cidade, como distribui\u00e7\u00e3o de casas e lojas, tamanhos de constru\u00e7\u00f5es, cores, popula\u00e7\u00e3o, consumo energ\u00e9tico, formas de movimenta\u00e7\u00e3o, etc. Entretanto, para descobrir a rota da sua posi\u00e7\u00e3o at\u00e9 uma loja, podemos abstrair quase tudo e considerar apenas com uma representa\u00e7\u00e3o de certas localiza\u00e7\u00f5es e dos acesso entre elas.</p> UnB \"Real\" Abstra\u00e7\u00e3o"},{"location":"pensamento_computacional/#projeto-de-algoritmos","title":"Projeto de Algoritmos","text":"<p>O passo final do pensamento computacional \u00e9 criar uma sequ\u00eancia de instru\u00e7\u00f5es que resolve o problema. O ponto chave \u00e9 guiar o racioc\u00ednio para construir a solu\u00e7\u00e3o. Para tanto, \u00e9 preciso considerar uma s\u00e9rie de coisas. Qual o objetivo principal? Como abstrair o contexto? Como decomp\u00f4-lo em partes mais acess\u00edveis? Em que ordem estas partes devem ser tratadas?</p> <p>Pensamento Algor\u00edtmico</p> <p>Processo de construir uma sequ\u00eancia de passos ordenados que pode ser seguida para obter uma solu\u00e7\u00e3o para todos os problemas constituintes necess\u00e1rios para resolver o problema original8.</p> <p>A aplica\u00e7\u00e3o do pensamento algor\u00edtmico depende de um bom entendimento do problema. \u00c9 preciso saber claramente quais as informa\u00e7\u00f5es fornecidas e o que se espera como resultado. Considere se h\u00e1 alguma parte que precisa ser repetida ou se h\u00e1 comportamentos diferentes dependendo de certas condi\u00e7\u00f5es. S\u00e3o pondera\u00e7\u00f5es necess\u00e1rias para desenvolver uma solu\u00e7\u00e3o.</p> <p>Dica</p> <p>Duas ideias que ajudam este processo s\u00e3o: 1) se perguntar \"E se eu fizesse desse jeito?\" (explorando formas diferentes de resolver o problema); e 2) explicar a sua solu\u00e7\u00e3o a algu\u00e9m (ou a um pato de borracha), ao tentar ensinar uma solu\u00e7\u00e3o voc\u00ea estar\u00e1 efetivamente aprendendo sobre ela.</p> <p>Com um entendimento adequado do problema e seu contexto, pode-se projetar o algoritmo. O grande Richard Feynman tem um abordagem muito interessante para a resolu\u00e7\u00e3o de problemas:</p> <p></p> <p>Alguns problemas n\u00e3o t\u00eam solu\u00e7\u00e3o, neles geralmente se aplica a abordagem \"consigo mostrar que ele n\u00e3o pode ser resolvido?\". Se sim, efetivamente ele est\u00e1 resolvido: n\u00e3o h\u00e1 solu\u00e7\u00e3o poss\u00edvel. Mesmo assim, a parte mais importante do processo \u00e9 o racioc\u00ednio aplicado no projeto do algoritmo.</p> Automa\u00e7\u00e3o <p>Considerando que muitas das atividades cotidianas s\u00e3o repetitivas e poderiam ser realizadas por um computador dadas as instru\u00e7\u00f5es corretas10, o uso de mecanismos para automa\u00e7\u00e3o de um algoritmo possibilita uma s\u00e9rie de vantagens. Pode aumentar a efici\u00eancia na produ\u00e7\u00e3o dos resultados e a uniformidade destes, reduzir a incid\u00eancia de erros e liberar recursos humanos para lidar com outras atividades.</p> <p>Parte importante deste processo \u00e9 o entendimento do que pode ou n\u00e3o ser computado. O computador existe como entidade f\u00edsica e opera dentro de certos limites. Portanto, apesar de podermos planejar solu\u00e7\u00f5es l\u00f3gica e matematicamente corretas, \u00e9 poss\u00edvel que estas n\u00e3o possam ser executadas na m\u00e1quina. Por exemplo, \u00e9 preciso compor um algoritmo baseado em instru\u00e7\u00f5es existentes no computador, algo como realize estas opera\u00e7\u00f5es matem\u00e1ticas sobre n\u00fameros \u00e9 vi\u00e1vel enquanto fa\u00e7a uma pizza n\u00e3o \u00e9. Mas pode ser mais complicado do que isso.</p> <p>Considere o problema de computar o valor de \\(\\pi\\). H\u00e1 m\u00e9todos para calcular o valor exato, mas ainda assim o resultado \u00e9 um valor irracional , ou seja, um n\u00famero infinamente longo que a m\u00e1quina n\u00e3o consegue processar. Ainda que conseguisse, seria necess\u00e1rio armazenar todos estes d\u00edgitos, o que imposs\u00edvel em um dispositivo com mem\u00f3ria limitada. Al\u00e9m disso, este processo envolve uma quantidade infinitamente grande de opera\u00e7\u00f5es, algo que a m\u00e1quina n\u00e3o poder\u00e1 realizar (nem o usu\u00e1rio esperar o resultado).</p> \\[\\pi = 4\\cdot\\sum\\limits_{n=0}^{\\infty}\\frac{(-1)^n}{2n+1}\\] <p>O processo de formula\u00e7\u00e3o de uma solu\u00e7\u00e3o algor\u00edtmica para ser automatizada necessariamente deve considerar essas limita\u00e7\u00f5es de modo a chegar a uma op\u00e7\u00e3o que seja realiz\u00e1vel.</p>"},{"location":"pensamento_computacional/#avaliacao","title":"Avalia\u00e7\u00e3o","text":"<p>A avalia\u00e7\u00e3o visa garantir que a solu\u00e7\u00e3o algor\u00edtmica \u00e9 adequada, ou seja, que resolve o problema. H\u00e1 diversas propriedades que podem/devem ser verificadas.</p> <ul> <li>Corretude: o algoritmo \u00e9 correto se fornece o resultado correto para toda entrada v\u00e1lida11.</li> <li>Efici\u00eancia: o algoritmo \u00e9 eficiente se consome o m\u00ednimo de recursos poss\u00edveis para fornecer um resultado; geralmente o foco \u00e9 em tempo (o qu\u00e3o r\u00e1pido \u00e9 sua execu\u00e7\u00e3o).</li> <li>Usabilidade: o qu\u00e3o f\u00e1cil \u00e9 para usar, lembrar e aprender o algoritmo12.</li> </ul> <p>A corretude \u00e9 a principal caracter\u00edstica, afinal as demais n\u00e3o t\u00eam import\u00e2ncia para uma solu\u00e7\u00e3o que n\u00e3o resolve o problema. Tamb\u00e9m \u00e9 um conceito ardiloso1 pois pode depender do contexto. Por exemplo, um algoritmo que aproxima o valor de \\(\\pi\\) pode ser correto num contexto em que a precis\u00e3o de 2 casas decimais \u00e9 suficiente (por exemplo, apresentando resultados simples \u00e0 pessoas), mas incorreto em outro onde a precis\u00e3o necessariamente deve ser bem maior (como calculando trajet\u00f3rias de naves espaciais). A efici\u00eancia n\u00e3o \u00e9 o foco da parte inicial mas ser\u00e1 discutida no futuro, e pode ser uma caracter\u00edstica fundamental da solu\u00e7\u00e3o em certos contexto (como o piloto autom\u00e1tico de uma aeronave). No\u00e7\u00f5es de usabilidade e legibilidade do c\u00f3digo permeiam o texto e ser\u00e3o destacadas quando apropriado.</p> <p>Esta verifica\u00e7\u00e3o \u00e9 um processo complexo, que pode ser feita de diversas formas. A mais simples \u00e9 testar o resultado obtido para situa\u00e7\u00f5es conhecidas, e fazer isso na totalidade das condi\u00e7\u00f5es poss\u00edveis ou numa abrang\u00eancia adequada. Quando isto n\u00e3o \u00e9 poss\u00edvel (talvez por que demore demais), h\u00e1 outras formas, como verificar as situa\u00e7\u00f5es antes (pr\u00e9-condi\u00e7\u00e3o) e depois (p\u00f3s-condi\u00e7\u00e3o) de cada passo no algoritmo, ele ser\u00e1 correto se e somente se ambas forem verdadeiras.</p> Resumo <p>O pensamento computacional \u00e9 o processo de formula\u00e7\u00e3o de problemas e solu\u00e7\u00f5es como algoritmos que podem ser tratados por um computador. Envolve a no\u00e7\u00e3o de quebrar o problema em partes menores, reconhecer similaridades entre elas e abstrair os pontos mais relevantes. Uma solu\u00e7\u00e3o algor\u00edtmica permite que a solu\u00e7\u00e3o seja aplicada por um agente qualquer, preferencialmente um automatizado computador. \u00c9 sempre importante avaliar se a solu\u00e7\u00e3o atende o problema em seu contexto.</p> <p>Por exemplo, dado o problema de ordenar uma lista de n\u00fameros em ordem crescente, tem-se:</p> Decomposi\u00e7\u00e3oReconhecimento de Padr\u00f5esAbstra\u00e7\u00e3oProjeto do AlgoritmoAutoma\u00e7\u00e3oAvalia\u00e7\u00e3o <ul> <li>Obter o primeiro n\u00famero do usu\u00e1rio.</li> <li>Escrever este n\u00famero em um papel.</li> <li>(repetir este processo para armazenar os n\u00fameros seguintes)</li> <li>Obter o \u00faltimo n\u00famero do usu\u00e1rio, se houver.</li> <li>Escrever este n\u00famero em um papel ao lado do \u00faltimo n\u00famero lido, se houver.</li> <li>Comparar o primeiro n\u00famero com o segundo.</li> <li>Se estiverem fora de ordem, trocar suas posi\u00e7\u00f5es.</li> <li>Se houve troca, registrar isto.</li> <li>(repetir este processo para comparar/trocar os n\u00fameros seguintes)</li> <li>Comparar o pen\u00faltimo n\u00famero com o \u00faltimo.</li> <li>Se estiverem fora de ordem, trocar suas posi\u00e7\u00f5es.</li> <li>Se houve troca, registrar isto.</li> <li>(repetir este processo de compara\u00e7\u00e3o/troca de todos os n\u00fameros at\u00e9 que n\u00e3o haja mais trocas - a lista est\u00e1 ordenada)</li> <li>Apresentar a lista ordenada.</li> </ul> <ol> <li>Obter um n\u00famero do usu\u00e1rio.</li> <li>Escrever este n\u00famero em um papel ao lado do \u00faltimo n\u00famero lido (se houver).</li> <li>Repetir os passos 1 e 2 at\u00e9 ter todos os n\u00fameros.</li> <li>Comparar o primeiro n\u00famero com o segundo.</li> <li>Se estiverem fora de ordem, trocar suas posi\u00e7\u00f5es.</li> <li>Se houve troca, registrar isto.</li> <li>Repetir esse processo de compara\u00e7\u00e3o/troca com pares de n\u00fameros sucessivos at\u00e9 lidar com os dois \u00faltimos n\u00fameros.</li> <li>Repetir os passos 4 a 7 at\u00e9 que n\u00e3o haja mais trocas (a lista est\u00e1 ordenada).</li> <li>Apresentar a lista ordenada.</li> </ol> <ol> <li>Entrada de dados</li> <li>Organiza\u00e7\u00e3o dos dados</li> <li>Enquanto os dados n\u00e3o estiverem em ordem<ol> <li>Compara\u00e7\u00e3o dos dados dois a dois</li> <li>Trocar dados fora de ordem</li> </ol> </li> <li>Sa\u00edda de dados</li> </ol> <ol> <li>Leia os dados em uma lista</li> <li>Enquanto a lista n\u00e3o estiver ordenada<ol> <li>Compare os dados dois a dois</li> <li>Troque dados fora de ordem</li> </ol> </li> <li>Apresente a lista</li> </ol> Programa em Python<pre><code># Leia os dados em uma lista.\ndados = list(map(int, input().split()))\n# Aqui s\u00e3o transformados em n\u00fameros, mas o algoritmo funciona para qualquer\n# tipo de dado que pode ser comparado.\n# Enquanto os dados n\u00e3o estiverem em ordem\nnum_dados = len(dados)\nhouve_troca = True\nwhile houve_troca:\nhouve_troca = False\n# Compare dos dados dois a dois\nfor primeiro in range(num_dados - 1):\nsegundo = primeiro + 1\n# Troque dados fora de ordem\nif dados[segundo] &lt; dados[primeiro]:\naux = dados[segundo]\ndados[segundo] = dados[primeiro]\ndados[primeiro] = aux\nhouve_troca = True\n# Apresente a lista\nprint(dados)\n</code></pre> <p>A avalia\u00e7\u00e3o pode ser feita feita matematicamente para cada passo, e verificada com testes abrangentes. Por exemplo:</p> <ul> <li>Se fornecermos os n\u00fameros 1 a sa\u00edda \u00e9 1 (correto).</li> <li>Se fornecermos os n\u00fameros 2, 1 a sa\u00edda \u00e9 1, 2 (correto).</li> <li>Se fornecermos os n\u00fameros 1, 2 a sa\u00edda \u00e9 1, 2 (correto).</li> <li>Se fornecermos os n\u00fameros 2, 1, 3 a sa\u00edda \u00e9 1, 2, 3 (correto).</li> <li>Se fornecermos os n\u00fameros 1, 2, 3 a sa\u00edda \u00e9 1, 2, 3 (correto).</li> <li>Se fornecermos os n\u00fameros 2, 3, 1 a sa\u00edda \u00e9 1, 2, 3 (correto).</li> <li>Se fornecermos os n\u00fameros 3, 2, 1 a sa\u00edda \u00e9 1, 2, 3 (correto).</li> <li>Se fornecermos os n\u00fameros 1, 5, 2, 4, 3 a sa\u00edda \u00e9 1, 2, 3, 4, 5 (correto).</li> <li>Se fornecermos os n\u00fameros 5, 4, 3, 2, 1 a sa\u00edda \u00e9 1, 2, 3, 4, 5 (correto).</li> <li>Se fornecermos os n\u00fameros 1, 2, 3, 4, 5 a sa\u00edda \u00e9 1, 2, 3, 4, 5 (correto).</li> <li>Se fornecermos os n\u00fameros 1, 2, 1, 1, 1 a sa\u00edda \u00e9 1, 1, 1, 1, 2 (correto).</li> </ul> Chatbot <ul> <li>O que \u00e9 pensamento computacional?</li> <li>O que \u00e9 pensamento algor\u00edtmico?</li> <li>De forma simplificada, o que \u00e9 corretude de um algoritmo?</li> <li>De forma simplificada, o que \u00e9 efici\u00eancia de um algoritmo?</li> <li>De forma simplificada, o que \u00e9 usabilidade de um algoritmo?</li> </ul> <p>Algumas op\u00e7\u00f5es s\u00e3o ChatGPT, Gemini, Claude e Llama. Estes modelos podem cometer erros! Verifique as informa\u00e7\u00f5es em fontes confi\u00e1veis.</p> Exerc\u00edcios H\u00e1 dois cubos aparentemente id\u00eanticos, sendo um um pouco mais leve que o outro. Aplique o pensamento computacional para elaborar uma solu\u00e7\u00e3o para o problema de, tendo acesso a uma balan\u00e7a digital, encontrar o mais pesado. <p>O processo pode ser decomposto em duas etapas: an\u00e1lise de um cubo e compara\u00e7\u00e3o dos resultados da an\u00e1lise. A solu\u00e7\u00e3o pode ser descrita nos seguintes passos:</p> <ol> <li>por o primeiro cubo na balan\u00e7a,</li> <li>anotar sua massa,</li> <li>por o segundo cubo na balan\u00e7a,</li> <li>anotar sua massa</li> <li>comparar os valores anotados</li> <li>identificar qual o de maior massa, e</li> <li>apresentar do cubo mais pesado.</li> </ol> H\u00e1 dois bolos aparentemente id\u00eanticos, sendo um pouco mais leve que o outro. Aplique o pensamento computacional para elaborar uma solu\u00e7\u00e3o para o problema de, tendo acesso a uma balan\u00e7a de dois pratos (que n\u00e3o indica a massa, mas apenas qual dos pratos tem mais peso), encontrar o bolo mais leve. <p>Este \u00e9 um problema diferente do anterior, mas alguns detalhes podem ser abstra\u00eddos: ao inv\u00e9s de bolos ou cubos, considera-se que h\u00e1 objetos a serem pesados; e em vez de um valor espec\u00edfico para a massa de cada objeto, tem-se um mecanismo que fornece o resultado direto da compara\u00e7\u00e3o entre eles. Novamente o processo pode ser decomposto em: disposi\u00e7\u00e3o dos objetos na balan\u00e7a e an\u00e1lise da inclina\u00e7\u00e3o dos pratos. A solu\u00e7\u00e3o pode ser descrita como:</p> <ol> <li>por cada objeto em um prato na balan\u00e7a,</li> <li>comparar a altura dos pratos, e</li> <li>apresentar o objeto que estiver no prato mais alto.</li> </ol> <p>Isso poderia ser facilmente adaptado para o problema de achar o objeto mais pesado.</p> Considere 1024 cubos aparentemente id\u00eanticos, sendo um deles um pouco mais pesado que os demais. Aplique o pensamento computacional para elaborar uma solu\u00e7\u00e3o para o problema de encontrar o cubo mais pesado com uma balan\u00e7a de dois pratos. <p>Uma abordagem \u00e9 aproveitar o comportamento descrito na quest\u00e3o anterior. Ao comparar dois cubos, se os pratos estiverem desalinhados sabe-se que o que estiver no prato mais baixo \u00e9 o desejado. Caso contr\u00e1rio, basta descartar um deles e substitu\u00ed-lo por outro cubo ainda n\u00e3o avaliado. Estes passos s\u00e3o repetidos at\u00e9 que se ache o mais pesado, o que pode levar at\u00e9 1023 compara\u00e7\u00f5es na balan\u00e7a.</p> <p>Alternativamente, retomando a abstra\u00e7\u00e3o de que \u00e9 um \"cubo\" pode ser considerado como um \"objeto\", a solu\u00e7\u00e3o descrita acima continua aplic\u00e1vel. Ao abstrair um pouco mais, considera-se que o \"objeto\" a ser pesado \u00e9, na verdade, um conjunto de cubos, e \u00e9 simples encontrar qual conjunto \u00e9 mais pesado comparando dois conjuntos com a mesma quantidade de objetos. Embora isso n\u00e3o forne\u00e7a ainda qual o cubo mais pesado, permite identificar em qual dos pratos ele est\u00e1 e, portanto, que se descarte os cubos do outro prato (o conjunto onde ele n\u00e3o est\u00e1). Assim, pode-se separar o conjunto em duas metades, compar\u00e1-los e descartar o mais leve. Sobra, ent\u00e3o, um novo conjunto de cubos que pode ser novamente separado em duas partes iguais para compara\u00e7\u00e3o na balan\u00e7a e subsequente descarte da parte mais leve. Esse processo \u00e9 repetido at\u00e9 que torne poss\u00edvel identificar inequivocadamente o cubo mais pesado. No caso de 1024 cubos, seriam necess\u00e1rias, no m\u00e1ximo, 10 compara\u00e7\u00f5es na balan\u00e7a!</p> Considere uma quantidade \u00edmpar de cubos aparentemente id\u00eanticos, sendo um deles um pouco mais leve que os demais. Como encontrar o cubo mais leve usando uma balan\u00e7a de dois pratos. <p>Pode-se aproveitar a ideia anterior para separ\u00e1-los em tr\u00eas partes, dois conjuntos com a mesma quantidade de cubos e um cubo a parte. Aos posicionar os conjuntos nos pratos, se n\u00e3o houver desn\u00edvel, o cubo separado \u00e9 o mais leve do conjunto. Se houver, pode-se descartar os cubos do prato mais pesado e tamb\u00e9m o que foi separado, e repetir o processo com os cubos remanescentes.</p> Nas solu\u00e7\u00f5es anteriores, como \u00e9 poss\u00edvel verificar que o processo \u00e9 correto? <p>H\u00e1 algumas possibilidades. \u00c9 poss\u00edvel que a objeto mais pesado possa ser identificado de outra forma (por exemplo, com uma marca\u00e7\u00e3o invis\u00edvel a olho nu), que possa ser verificada ao final do processo. Outra forma \u00e9 avaliando se cada passo est\u00e1 correto. No caso da balan\u00e7a de dois pratos, sempre que houver pelo menos um objeto, o prato mais baixo indica aquele mais pesado (mesmo que haja dois com o mesmo peso!). Isso tamb\u00e9m \u00e9 verdade se forem dois conjuntos de objetos, um em cada prato, ou seja, cada pesagem corretamente indica o conjunto mais pesado. Se este passo \u00e9 avaliado como correto, diferentes repeti\u00e7\u00f5es dele tamb\u00e9m o ser\u00e3o. Ou seja, ao pesar uma vez e descartar o conjunto mais leve, tem-se novamente o problema de achar o objeto mais pesado em um conjunto menor de objetos - uma vers\u00e3o menor do mesmo problema de antes! O processo de compara\u00e7\u00e3o e descarte, que \u00e9 correto, pode ser repetido at\u00e9 que haja somente dois objetos, situa\u00e7\u00e3o que j\u00e1 foi mostrada que pode ser resolvida corretamente.</p> <ol> <li> <p>Thomas H. Cormen. Algorithms Unlocked. The MIT Press, 2013. ISBN 9780262518802. URL: https://mitpress.mit.edu/9780262518802/algorithms-unlocked/.\u00a0\u21a9\u21a9</p> </li> <li> <p>Alfred V. Aho. Ubiquity symposium: computation and computational thinking. Ubiquity, jan 2011. URL: https://doi.org/10.1145/1922681.1922682, doi:10.1145/1922681.1922682.\u00a0\u21a9</p> </li> <li> <p>Jeannette M Wing. Computational thinking benefits society. 2014. URL: http://socialissues.cs.toronto.edu/index.html%3Fp=279.html.\u00a0\u21a9</p> </li> <li> <p>International Society for Technology in Education. Iste standards. 2018. URL: https://www.iste.org/standards.\u00a0\u21a9</p> </li> <li> <p>The Chartered Institute for IT. Call for evidence - UK Digital Skills Taskforce. 2014.\u00a0\u21a9</p> </li> <li> <p>Computational Thinking Concepts Guide. URL: https://docs.google.com/document/d/1Hyb2WKJrjT7TeZ2ATq6gsBhkQjSZwTH-xfpVMFEn2F8/edit?pli=1.\u00a0\u21a9</p> </li> <li> <p>Erin Burgoon, Marlone Henderson, and Arthur Markman. There are many ways to see the forest for the trees a tour guide for abstraction. Perspectives on Psychological Science, 8:501\u2013520, 09 2013. doi:10.1177/1745691613497964.\u00a0\u21a9</p> </li> <li> <p>Fatih Kursat Cansu and Sibel Kilicarslan Cansu. An overview of computational thinking. International Journal of Computer Science Education in Schools, 3(1):17\u201330, Apr. 2019. URL: https://www.ijcses.org/index.php/ijcses/article/view/53, doi:10.21585/ijcses.v3i1.53.\u00a0\u21a9\u21a9</p> </li> <li> <p>Timothy Colburn and Gary Shute. Abstraction in computer science. Minds and Machines, 17:169\u2013184, 2007. URL: https://www.d.umn.edu/~tcolburn/papers/Abstraction.pdf.\u00a0\u21a9</p> </li> <li> <p>Al Sweigart. Automate the Boring Stuff with Python. William Pollock, 2020. ISBN 978-1-59327-992-9. URL: https://automatetheboringstuff.com/.\u00a0\u21a9</p> </li> <li> <p>Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms. The MIT Press, 2009. ISBN 0-262-03384-4.\u00a0\u21a9</p> </li> <li> <p>Rajat Jain, Tania Joseph, Anvita Saxena, Deepak Gupta, Ashish Khanna, Kalpna Sagar, and Anil K. Ahlawat. Feature selection algorithm for usability engineering: a nature inspired approach. Complex &amp; Intelligent Systems, 9(4):3487\u20133497, 2023. doi:10.1007/s40747-021-00384-z.\u00a0\u21a9</p> </li> </ol>"},{"location":"programacao/","title":"Programa\u00e7\u00e3o","text":"<p>Larry O\u2019Brien &amp; Bruce Eckel</p> <p>Programa\u00e7\u00e3o de computadores \u00e9 muito divertida. Como m\u00fasica, \u00e9 uma habilidade originada da mistura de um talento natural e pr\u00e1tica constante.</p> <p></p> <p>Como o programa resultante determina o comportamento obtido, pode-se considerar a programa\u00e7\u00e3o como a a\u00e7\u00e3o de instruir um computador sobre como realizar algum tipo de opera\u00e7\u00e3o - \u00e9 uma forma de se comunicar com a m\u00e1quina.</p> <p>Um computador \u00e9 utilizado na resolu\u00e7\u00e3o de problemas, e geralmente um \"usu\u00e1rio\" fornece informa\u00e7\u00f5es para isso enquanto um \"programador\" define novas opera\u00e7\u00f5es (e tipos de dados)1 que resultam em novas solu\u00e7\u00f5es. O papel do programador \u00e9 usar e orquestrar cada recurso (componentes do computador) para resolver um problema e analisar os dados que obtiver desta solu\u00e7\u00e3o2.</p> <p>Programa\u00e7\u00e3o</p> <p>Programa\u00e7\u00e3o \u00e9 o processo de expressar um algoritmo como instru\u00e7\u00f5es em uma linguagem de programa\u00e7\u00e3o.</p>"},{"location":"programacao/#linguagem-de-programacao","title":"Linguagem de Programa\u00e7\u00e3o","text":"<p>A linguagem de programa\u00e7\u00e3o \u00e9 um conjunto de termos (vocabul\u00e1rio) e regras (sintaxe) que permite a formula\u00e7\u00e3o de instru\u00e7\u00f5es para um computador, viabilizando a express\u00e3o de um algoritmo de tal modo que possa ser executado pela m\u00e1quina. O vocabul\u00e1rio determina o conjunto de termos que t\u00eam significado especificado na linguagem e que deve ser usado na composi\u00e7\u00e3o das instru\u00e7\u00f5es. A sintaxe determina como usar o vocabul\u00e1rio para formar instru\u00e7\u00f5es (gramaticalmente) corretas na linguagem. O significado computacional de uma instru\u00e7\u00e3o v\u00e1lida \u00e9 a sem\u00e2ntica.</p> <p>Esses conceitos existem tamb\u00e9m na l\u00edngua portuguesa. Pode-se construir uma frase com vocabul\u00e1rio inexistente como \"Mxyzptlk zxcvbnm\", ou uma com termos conhecidos mas sint\u00e1tica e semanticamente incorreta como \"p\u00e3o ela navegou\"; sintaticamente correta mas semanticamente incorreta como \"ela navegou p\u00e3o\" e tamb\u00e9m a frase correta \"ela comeu p\u00e3o\".</p> <p>Programa\u00e7\u00e3o / Linguagem de programa\u00e7\u00e3o</p> <p>Programa\u00e7\u00e3o \u00e9 o processo de transformar o algoritmo em instru\u00e7\u00f5es em uma linguagem de programa\u00e7\u00e3o, que permite a formula\u00e7\u00e3o de instru\u00e7\u00f5es a um computador. A linguagem de programa\u00e7\u00e3o \u00e9 um conjunto de termos (vocabul\u00e1rio) e regras (sintaxe) que permite a formula\u00e7\u00e3o de instru\u00e7\u00f5es para um computador.</p> <p>Toda linguagem de programa\u00e7\u00e3o \u00e9 baseada em instru\u00e7\u00f5es primitivas, as entidades mais simples que ela trata; em formas de combina\u00e7\u00e3o destes elementos simples, e em formas de abstra\u00e7\u00e3o destas combina\u00e7\u00f5es de modo que possam tamb\u00e9m ser consideradas como primitivas3. Por exemplo, pode-se combinar muitas instru\u00e7\u00f5es primitivas necess\u00e1rias para exibir uma mensagem na sa\u00edda padr\u00e3o de tal forma que este processo seja f\u00e1cil e intuitivamente obtido por uma nova primitiva: <code>print</code>.</p> <p>Alan Turing mostrou que 6 primitivas s\u00e3o suficientes para computar qualquer coisa [comput\u00e1vel]. Assim, uma linguagem de programa\u00e7\u00e3o [Turing-completa] define tanto a sintaxe quanto a sem\u00e2ntica necess\u00e1rias para traduzir o pensamento computacional em passos que um computador pode executar.</p> <p>As linguagens modernas t\u00eam um conjunto maior e mais conveniente de primitivas que as 6 de Turing, e permitem que voc\u00ea as agrupe para elaborar programas mais complexos. Estas novas abstra\u00e7\u00f5es tamb\u00e9m podem ser agrupadas, e assim sucessivamente. Por exemplo, as primitivas mais comuns s\u00e3o: n\u00fameros (\\(1\\), \\(-2\\), \\(3.14\\)), s\u00edmbolos (\"@\", \"Alan M. Turing\", \":)\"), e opera\u00e7\u00f5es simples (\\(+\\), \\(-\\), \\(\\times\\), \\(\\div\\)).</p> <p>A sintaxe da linguagem indica quais express\u00f5es s\u00e3o simbolicamente corretas (<code>1 + 1</code>), ou n\u00e3o (<code>Jo\u00e3o \u00f7</code>). A sem\u00e2ntica lida com o significado associado a uma express\u00e3o sintaticamente correta, que pode ser logicamente correto (<code>dois = 1 + 1</code>) ou n\u00e3o (<code>area_do_quadrado = lado + lado</code>). Erros sint\u00e1ticos s\u00e3o relativamente f\u00e1ceis de se encontrar, mas o mesmo n\u00e3o pode ser dito sobre erros sem\u00e2nticos.</p> <p>A linguagem de m\u00e1quina \u00e9 a que o hardware [espec\u00edfico] entende (c\u00f3digo bin\u00e1rio). A vantagem \u00e9 que n\u00e3o \u00e9 preciso gastar esfor\u00e7os traduzindo instru\u00e7\u00f5es, mas \u00e9 praticamente incompreens\u00edvel para humanos [normais].</p> <p>Uma linguagem de baixo n\u00edvel usa instru\u00e7\u00f5es mnem\u00f4nicas para tentar facilitar a programa\u00e7\u00e3o. A vantagem \u00e9 ser muito mais intelig\u00edvel que a de m\u00e1quina, mas tamb\u00e9m \u00e9 pouco amig\u00e1vel e, dependendo do hardware utilizado, precisa ser traduzida para linguagem de m\u00e1quina.</p> <p>J\u00e1 uma linguagem de alto n\u00edvel usa um vocabul\u00e1rio mais rico para facilitar programa\u00e7\u00e3o. \u00c9 \"facilmente\" aprendida e independente do hardware, mas precisa ser traduzida para linguagem de m\u00e1quina. As linguagens de alto n\u00edvel claramente possibilitam programas mais breves e leg\u00edveis, mas o fazem pela composi\u00e7\u00e3o e abstra\u00e7\u00e3o das primitivas da m\u00e1quina. Conhecendo uma linguagem de programa\u00e7\u00e3o, pode-se elaborar programas bem interessantes.</p> <p>O exemplo tradicional \u00e9 o \"Ol\u00e1 mundo!\".</p> PythonRustCAssemblyC\u00f3digo Bin\u00e1rio Ol\u00e1 mundo!<pre><code>print('Ola mundo!')\n</code></pre> Ol\u00e1 mundo!<pre><code>fn main() {\nprintln!(\"Hello World!\");\n}\n</code></pre> Ol\u00e1 mundo!<pre><code>#include &lt;stdio.h&gt;\nint main() {\nprintf(\"Ola mundo!\\n\");\nreturn 0;\n}\n</code></pre> Ol\u00e1 mundo!<pre><code>section .data\nmsg     db      'Ola mundo!', 0AH\nlen     equ     $-msg\n\nsection .text\nglobal  _start\n_start: mov     edx, len\n        mov     ecx, msg\n        mov     ebx, 1\n        mov     eax, 4\n        int     80h\n\n        mov     ebx, 0\n        mov     eax, 1\n        int     80h\n</code></pre> Ol\u00e1 mundo!<pre><code>0111 1111 0100 0101 0100 1100 0100 0110\n0000 0010 0000 0001 0000 0001 0000 0000\n0000 0000 0000 0000 0000 0000 0000 0000\n0000 0000 0000 0000 0000 0000 0000 0000\n0000 0010 0000 0000 0011 1110 0000 0000\n0000 0001 0000 0000 0000 0000 0000 0000\n0100 0000 0000 0100 0100 0000 0000 0000\n0000 0000 0000 0000 0000 0000 0000 0000\n(continua por mais 2120 linhas)\n</code></pre> <p>Note</p> <p>Compreender os fundamentos e t\u00e9cnicas de programa\u00e7\u00e3o \u00e9 mais importante que dominar uma linguagem espec\u00edfica.</p> <p>Havendo um programa sintaticamente correto, \u00e9 preciso traduzi-lo da linguagem de alto n\u00edvel para a linguagem de m\u00e1quina para que haja instru\u00e7\u00f5es que o computador usado consiga interpretar (cada dispositivo fala sua pr\u00f3pria linguagem). Neste processo, o c\u00f3digo fonte \u00e9 verificado para garantir que n\u00e3o cont\u00e9m erros sint\u00e1ticos. Dependendo da implementa\u00e7\u00e3o da linguagem, este c\u00f3digo \u00e9 compilado, gerando um objeto (a vers\u00e3o das instru\u00e7\u00f5es originais em bin\u00e1rio) que, por sua vez, \u00e9 interpretado por um programa gerando um arquivo que pode ser executado.</p> <p>Qualquer linguagem de programa\u00e7\u00e3o pode ser interpretada ou compilada, estas s\u00e3o formas de implementa\u00e7\u00e3o (e n\u00e3o caracter\u00edsticas da linguagem) que n\u00e3o s\u00e3o, necessariamente, exclusivas. A interpreta\u00e7\u00e3o \u00e9 realizada por um programa espec\u00edfico (o interpretador) que realiza as instru\u00e7\u00f5es pelo programa sendo interpretado de modo que este seja executado. Imagine que, a cada passo, uma instru\u00e7\u00e3o \u00e9 interpretada e executada. J\u00e1 a compila\u00e7\u00e3o (realizada pelo programa compilador) traduz completamente o programa original em c\u00f3digo objeto que pode ser executado pela m\u00e1quina.</p> <p>A interpreta\u00e7\u00e3o tende a ser mais port\u00e1til, e tem a \"vantagem\" de realizar um passo de cada vez, j\u00e1 a compila\u00e7\u00e3o pode a gerar c\u00f3digo otimizado e que n\u00e3o precisa ser interpretado a cada instru\u00e7\u00e3o. Outra diferen\u00e7a \u00e9 que interpretadores s\u00e3o mais simples de se construir que compiladores.</p> <p>Existem diversas ferramentas para realizar este processo, como o compilador GCC para linguagem C ou o interpretador Python 3. No caso do exemplo abaixo, supondo que se esteja no diret\u00f3rio do arquivo com c\u00f3digo fonte, bastaria executar na linha de comando:</p> PythonC Ol\u00e1 mundo!<pre><code>$ python ola_mundo.py\n</code></pre> Ol\u00e1 mundo!<pre><code>$ gcc ola_mundo.c -o ola_mundo\n$ ./ola_mundo\n</code></pre>"},{"location":"programacao/#conceitos-basicos","title":"Conceitos B\u00e1sicos","text":"<p>A execu\u00e7\u00e3o do programa passa pela interpreta\u00e7\u00e3o das instru\u00e7\u00f5es apresentadas. Uma instru\u00e7\u00e3o <code>&lt;instr&gt;</code> \u00e9 um comando sintaticamente correto que pode ser diretamente executado. J\u00e1 uma express\u00e3o <code>&lt;expr&gt;</code> \u00e9 uma instru\u00e7\u00e3o que precisa ser interpretada e que produz um resultado (que pode ser armazenado). Por exemplo, ao interagir com um agente humano como executor do algoritmo, ele entende a instru\u00e7\u00e3o <code>&lt;Levante&gt;</code> e a realiza, mas n\u00e3o h\u00e1 uma informa\u00e7\u00e3o produzida como resultado disto. Em seguida, podemos passar a express\u00e3o <code>&lt;Fale seu nome&gt;</code>, cujos termos precisam ser analisados e interpretados no contexto para que o agente possa reconhecer quem deve executar (o pr\u00f3prio agente), qual a a\u00e7\u00e3o  a ser executada (falar) e sobre o que ela deve executar (o nome) - s\u00f3 ent\u00e3o ele pode executar o que foi solicitado e produzir uma nova informa\u00e7\u00e3o (o nome falado), que se pode ser armazenado (ou n\u00e3o) para uma necessidade futura.</p> <p>Uma express\u00e3o pode ser composta por apenas um valor, como <code>&lt;Pedro&gt;</code> ou <code>&lt;42&gt;</code>, e tamb\u00e9m por diferentes valores e operadores. A express\u00e3o <code>2 + 3</code> produz o resultado 5 ao ser executada.</p> Instru\u00e7\u00f5esExpress\u00f5es Python<pre><code>pass\n</code></pre> Python<pre><code>&gt;&gt;&gt; 21 * 2\n42\n&gt;&gt;&gt; 20 - (2 ** 3 - 1)\n7\n&gt;&gt;&gt; -1 + (-4 * 2.5 + 3 / 2)\n-9.5\n</code></pre>"},{"location":"programacao/#constantes-variaveis","title":"Constantes &amp; Vari\u00e1veisResumoExerc\u00edcios","text":"<p>Constante</p> <p>Uma constante <code>&lt;C&gt;</code> \u00e9 um valor armazenado que n\u00e3o \u00e9 alterado no decorrer do processamento.</p> <p>Vari\u00e1vel</p> <p>Uma vari\u00e1vel <code>&lt;v&gt;</code> \u00e9 um valor armazenado que pode ser alterado no decorrer do processamento.</p> ConstantesVari\u00e1veis Python<pre><code>&gt;&gt;&gt; math.pi\n3.141592653589793\n</code></pre> Python<pre><code>&gt;&gt;&gt; y = 13\n&gt;&gt;&gt; x = 42\n&gt;&gt;&gt; y = 123  # o valor de x n\u00e3o foi alterado, mas o de y sim.\n</code></pre> <p>Vari\u00e1veis e constantes exigem um pouco mais de...</p> <p></p> Llm <ul> <li>O que faz um programador?</li> <li>Explique o conceito de linguagem de programa\u00e7\u00e3o.</li> <li>Qual a diferen\u00e7a entre instru\u00e7\u00e3o e express\u00e3o em uma linguagem de programa\u00e7\u00e3o?</li> </ul> <p></p>"},{"location":"programacao/#tipos-de-dados","title":"Tipos de Dados","text":"<p>Daniel Keys Moran</p> <p>Voc\u00ea pode ter dados sem informa\u00e7\u00e3o, mas n\u00e3o pode ter informa\u00e7\u00e3o sem dados.</p> <p></p> <p>Todo processo no computador gerencia a execu\u00e7\u00e3o de um programa armazenado, a implementa\u00e7\u00e3o de um algoritmo computacional n\u00e3os sendo, portanto, poss\u00edvel dissociar um algoritmo de dados manipulados - o pr\u00f3prio programa \u00e9 um conjunto de dados (as instru\u00e7\u00f5es). Al\u00e9m disso, praticamente todos os programas manipulas dados fornecidos e gerados no processamento, na forma de vari\u00e1veis ou constantes, que s\u00e3o os objetos de dados b\u00e1sicos manipulados em um programa4.</p> <p>O forma como organizamos estes dados tem impacto direto no desempenho do computador. Ao executar um algoritmo computacional, estamos exigindo esfor\u00e7o da m\u00e1quina para realizar o trabalho de processamento. Este esfor\u00e7o depende da quantidade de instru\u00e7\u00f5es sendo executadas, e do custo de cada instru\u00e7\u00f5es (podemos ter instru\u00e7\u00f5es mais simples e baratas, e instru\u00e7\u00f5es mais complexas e caras). A organiza\u00e7\u00e3o dos dados tem impacto direto neste esfor\u00e7o, e buscamos deix\u00e1-los organizados de forma a tornar o processo menos custoso. Por exemplo, imagine que seu problema \u00e9 interpretar n\u00fameros e som\u00e1-los, \u00e9 muito mais f\u00e1cil1 fazer isso se lhe forem apresentados os n\u00fameros estruturados como \\(49\\) e \\(1\\) (com resultado \\(50\\)) que se fossem como \\(XLIX\\) e \\(I\\) (tamb\u00e9m com resultado \\(L\\)).</p> <p>A mem\u00f3ria do computador \u00e9 um conjunto ordenado de bits, ou seja, toda informa\u00e7\u00e3o \u00e9 armazenada como zeros e uns e h\u00e1 uma ordem posicional entre eles (existe um primeiro bit, que pode ser <code>0/1</code>, um segundo bit que tamb\u00e9m pode ser <code>0/1</code>, e assim sucessivamente at\u00e9 um \u00faltimo bit). Para facilitar, h\u00e1 uma nomenclatura espec\u00edfica para lidar com a quantidade de bits sendo 1 byte (8 bits) a unidade mais comum para quantific\u00e1-lo. A composi\u00e7\u00e3o de bits permite representar mais estados; 2 bits s\u00e3o 4 estados (<code>00/01/11/10</code>), 3 bits definem 8 estados, e assim sucessivamente - havendo \\(n\\) bits podemos definir \\(2^n\\) estados distintos. O significado da informa\u00e7\u00e3o armazenada depende da forma de interpretar estes bits, um mesmo conjunto de bits tem significados diferentes se for interpretado como um n\u00famero, um s\u00edmbolo ou outra coisa. Por exemplo, um byte pode assumir um de 256 valores num\u00e9ricos diferentes, mas tamb\u00e9m pode representar in\u00fameras informa\u00e7\u00f5es diferentes se mudarmos a forma de interpret\u00e1-lo.</p> <p></p> <p>A representa\u00e7\u00e3o do dado \u00e9 necessariamente bin\u00e1ria mas a interpreta\u00e7\u00e3o dos bits \u00e9 o que define a informa\u00e7\u00e3o. Esta interpreta\u00e7\u00e3o \u00e9 determinada pelo tipo de dado, e cada tipo tem suas caracter\u00edsticas espec\u00edficas definidas pela linguagem de programa\u00e7\u00e3o. Por exemplo, o conjunto de bits <code>01000001001000000000000000000000</code> pode ser interpretado como o valor num\u00e9rico do tipo inteiro 1092616192, como o valor num\u00e9rico do tipo real 10.0 ou como um tipo simb\u00f3lico <code>A</code> (ASCII). Estes tr\u00eas tipos de dados, entre outros, geralmente est\u00e3o presentes em qualquer linguagem de programa\u00e7\u00e3o.</p> <p>Note</p> <p>Como um mesmo conjunto de bits pode ser interpretado de diferentes formas, \u00e9 preciso saber que tipo de dado foi armazenado na mem\u00f3ria para interpret\u00e1-lo corretamente.</p> <p>Um tipo abstrato de dado (TAD) determina um tipo de dado e as opera\u00e7\u00f5es definidas sobre ele, delimitando assim a quantidade de informa\u00e7\u00e3o necess\u00e1ria para manipula\u00e7\u00e3o dos valores pelo computador e, consequentemente, facilitando a programa\u00e7\u00e3o. Por exemplo, o conjunto de n\u00fameros naturais \\(\\mathbb{N}\\) e suas opera\u00e7\u00f5es (como \\(+, -, /, *\\)) \u00e9 um TAD.</p> <p>Estrutura de Dados</p> <p>Forma concreta de se implementar um tipo abstrato de dados em uma linguagem de programa\u00e7\u00e3o, de modo a organizar os dados na mem\u00f3ria para facilitar o acesso e a manipula\u00e7\u00e3o destes.</p> <p>Portanto, para cada linguagem de programa\u00e7\u00e3o espec\u00edfica, o tipo do dado determina:</p> <ol> <li>o significado do valor armazenado;</li> <li>como o valor \u00e9 armazenado nos bits;</li> <li>quais os poss\u00edveis valores que podem ser armazenados; e</li> <li>quais as opera\u00e7\u00f5es podem ser realizadas com o valor.</li> </ol> <p>Note</p> <p>As caracter\u00edsticas de uma estrutura de dados espec\u00edfica s\u00e3o importantes pois determinam o que pode e tamb\u00e9m o que n\u00e3o pode ser feito com ela.</p> Resumo <p></p> Llm <ul> <li>Explique o conceito de tipo de dados em programa\u00e7\u00e3o.</li> <li>O que \u00e9 o fluxo de controle de um programa?</li> </ul> Exerc\u00edcios Dado um n\u00famero n\u00e3o negativo qualquer na base hexadecimal, descreva o algoritmos para transform\u00e1-lo em um n\u00famero bin\u00e1rio. <p>Como a base 16 \u00e9 m\u00faltipla de 2, o processo manual \u00e9 bem simples. Cada algarismo hexadecimal pode ser diretamente mapeado para seu valor bin\u00e1rio de 4 bits, na mesma ordem. Por exemplo, para \\(2A_{16}\\) temos que \\(2_{16} \\rightarrow 0010_2\\) e \\(A_{16} \\rightarrow 1010_2\\), portanto \\(2A_{16}\\rightarrow 00101010_2\\).</p>"},{"location":"programacao/#numeros","title":"N\u00fameros","text":"<p>Um n\u00famero \u00e9 um objeto matem\u00e1tico usado para descrever uma quantidade, e uma base num\u00e9rica \u00e9 um conjunto de algarismos utilizados para representar um n\u00famero. Quais s\u00e3o os s\u00edmbolos e as regras de como utiliz\u00e1-los s\u00e3o definidos pelos sistema de numera\u00e7\u00e3o usado. O valor de um n\u00famero \u00e9 \u00fanico, mas sua representa\u00e7\u00e3o pode variar conforme o sistema utilizado - \u00e9 f\u00e1cil ilustrar isso comparando o abordagem usamos normalmente, com algarismos ar\u00e1bicos e a nota\u00e7\u00e3o posicional, \u00e0 abordagem que os antigos romanos usavam. Para o valor quarenta e nove, temos as representa\u00e7\u00f5es \\(49\\) e \\(XLIX\\), respectivamente.</p> <p>Na nota\u00e7\u00e3o posicional, o valor representado por um algarismo depende da posi\u00e7\u00e3o em que ele se encontra no conjunto de s\u00edmbolos que representa o n\u00famero, sendo valores a esquerda mais influentes que os a direita. O valor deste n\u00famero \u00e9 determinado pela soma dos valores relativos de cada algarismo. Por exemplo: 123 = 100 + 20 + 3, o algarismo mais a esquerda (1) tem uma influ\u00eancia maior que os demais no valor, e \u00e9 considerado o mais significativo. O algarismo seguinte (2) tem uma influ\u00eancia menor que o anterior, mas maior que o seguinte. Isso se sucede at\u00e9 o \u00faltimo algarismo, o mais a direita, que \u00e9 chamado de menos significativo. Podemos reescrever a informa\u00e7\u00e3o da seguinte forma:</p> \\[123 = 100 + 20 + 3 = 1\u00b710^2+ 2\u00b710^1+ 3\u00b710^0\\] <p>Nesta representa\u00e7\u00e3o, duas coisas se destacam. A primeira \u00e9 que a influ\u00eancia de cada algarismo \u00e9 determinada por uma pot\u00eancia de 10, que \u00e9 a base num\u00e9rica. A segunda, \u00e9 que esta pot\u00eancia \u00e9 uma sequ\u00eancia crescente da posi\u00e7\u00e3o menos significativa para a mais significativa, iniciando-se por 0. De forma mais gen\u00e9rica, um algarismo \\(A\\) tem uma influ\u00eancia proporcional a sua posi\u00e7\u00e3o \\(i\\) para uma base num\u00e9rica \\(B\\).</p> \\[A\u00b7{B^i}\\] <p>No valor 123, na base decimal, entendemos seu valor pela soma de seus componentes. O algarismo 3 est\u00e1 na posi\u00e7\u00e3o mais a direita, considerada como posi\u00e7\u00e3o \\(i = 0\\), portanto seu peso no valor resultante \u00e9 de 3\u00b710\\(^0\\). A posi\u00e7\u00e3o seguinte (a esquerda) \u00e9 i = 1 com o algarismo 2, acrescentando 2\u00b710\\(^1\\) ao resultado. O \u00faltimo algarismo (mais a esquerda) \u00e9 1 e est\u00e1 na posi\u00e7\u00e3o 2, acrescentando 1\u00b710\\(^2\\). De forma gen\u00e9rica, o valor de um n\u00famero em uma base num\u00e9rica \\(B\\) qualquer, representado com \\(n\\) algarismos \\(A_i : A \\in [0, B), i \\in [0, n)\\), \u00e9 calculado com a seguinte f\u00f3rmula:</p> \\[A_{n-1}A_{n-2}\u2026{A_2}A_1A_0 = \\sum\\limits_{i=0}^{n - 1}{A_i\u00b7{B^i}}\\] <p>Para representar a informa\u00e7\u00e3o num\u00e9rica na mem\u00f3ria do computador, ela necessariamente deve ser representada como um conjunto de bits. Isto \u00e9 relativamente simples, o bit tem dois estados, 0/1 que s\u00e3o os algarismos da base num\u00e9rica bin\u00e1ria. Portanto, podemos usar esta base na nota\u00e7\u00e3o posicional para basta representar um valor num\u00e9rico qualquer como bits na mem\u00f3ria. Como tamb\u00e9m usaremos algarismos ar\u00e1bicos, para diferenciar as bases num\u00e9ricas acrescentamos um sufixo ao n\u00famero.</p> \\[1101_2 = 1\u00b72^3+ 1\u00b72^2+ 0\u00b72^1+ 1\u00b72^0 = 8 + 4 + 0 + 1 = 13_{10}\\] <p>Por ser uma base de valor baixo, s\u00e3o poucos os algarismos e, portanto, as representa\u00e7\u00f5es dos n\u00fameros se tornam extensas. Outras bases de valor mais elevado permitem compactar isso, e as mais \u00fateis s\u00e3o as m\u00faltiplas de 2 j\u00e1 que a convers\u00e3o delas para a bin\u00e1ria \u00e9 simplificada. A tabela abaixo mostra alguns valores nas bases mais comuns na computa\u00e7\u00e3o: bin\u00e1ria, octal, decimal e hexadecimal. Note que, como a nota\u00e7\u00e3o posicional utiliza apenas um s\u00edmbolo por posi\u00e7\u00e3o, a base hexadecimal define os valores superiores a 9 (o maior algarismo ar\u00e1bico) para letras do alfabeto latino.</p> <p> bin\u00e1ria octal decimal hexadecimal 0 0 0 0 1 1 1 1 10 2 2 2 11 3 3 3 100 4 4 4 101 5 5 5 110 6 6 6 111 7 7 7 1000 10 8 8 1001 11 9 9 1010 12 10 A 1011 13 11 B 1100 14 12 C 1101 15 13 D 1110 16 14 E 1111 17 15 F 101010 52 42 2A 1111011 173 123 7B <p></p>"},{"location":"programacao/#numeros-inteiros","title":"N\u00fameros Inteiros","text":"<p>J\u00e1 vimos a representa\u00e7\u00e3o dos n\u00fameros naturais em bin\u00e1rio. Entretanto, muitas problemas lidam com os n\u00fameros inteiros, que podem ter valores negativos. Felizmente, um n\u00famero s\u00f3 pode ser negativo ou n\u00e3o, ou seja, a informa\u00e7\u00e3o do sinal \u00e9 facilmente representada em um bit. A conven\u00e7\u00e3o \u00e9 que o bit mais a esquerda armazena a informa\u00e7\u00e3o se o n\u00famero \u00e9 negativo (ligado/1) ou se \u00e9 positivo (desligado/0), e os demais bits armazenam a informa\u00e7\u00e3o do valor do n\u00famero. H\u00e1 formas distintas de se interpretar este \u00faltimo conjunto de bits, como listadas a seguir.</p> <p>Sinal e Magnitude, onde o bit mais significativo indica o sinal e os demais bits determinam o valor diretamente pela nota\u00e7\u00e3o posicional (como um n\u00famero natural). Esta abordagem \u00e9 intuitivamente simples para entendermos.</p> <p> bits sinal nota\u00e7\u00e3o posicional decimal 000 +00 \\(+(0\u00b72^1+ 0\u00b72^0)\\) +0 001 +01 \\(+(0\u00b72^1+ 1\u00b72^0)\\) +1 010 +10 \\(+(1\u00b72^1+ 0\u00b72^0)\\) +2 011 +11 \\(+(1\u00b72^1+ 1\u00b72^0)\\) +3 100 -00 \\(-(0\u00b72^1+ 0\u00b72^0)\\) -0 101 -01 \\(-(0\u00b72^1+ 1\u00b72^0)\\) -1 110 -10 \\(-(1\u00b72^1+ 0\u00b72^0)\\) -2 111 -11 \\(-(1\u00b72^1+ 1\u00b72^0)\\) -3 <p></p> <p>Complemento de um tamb\u00e9m considera o bit mais a esquerda como indicador de sinal e os demais para o valor, conforme o sinal. Se positivo, os bits restantes indicam o valor pela nota\u00e7\u00e3o posicional (como na abordagem de sinal e magnitude); se negativo, \u00e9 preciso inverter todos os bits antes de considerar a nota\u00e7\u00e3o posicional. Esta varia\u00e7\u00e3o \u00e9 um pouco mais complexa para entendermos, mas tem vantagens quanto \u00e0 anterior para algumas opera\u00e7\u00f5es. Uma delas \u00e9 que precisa-se de menos esfor\u00e7o para para inverter o sinal de um valor, uma opera\u00e7\u00e3o muito frequente em problemas computacionais. Usando complemento de um, basta inverter todos os bits.</p> <p> bits sinal inverte? nota\u00e7\u00e3o posicional decimal 000 +00 n\u00e3o +00 \\(+(0\u00b72^1+ 0\u00b72^0)\\) +0 001 +01 n\u00e3o +01 \\(+(0\u00b72^1+ 1\u00b72^0)\\) +1 010 +10 n\u00e3o +10 \\(+(1\u00b72^1+ 0\u00b72^0)\\) +2 011 +11 n\u00e3o +11 \\(+(1\u00b72^1+ 1\u00b72^0)\\) +3 100 -00 sim -11 \\(-(1\u00b72^1+ 1\u00b72^0)\\) -3 101 -01 sim -10 \\(-(1\u00b72^1+ 0\u00b72^0)\\) -2 110 -10 sim -01 \\(-(0\u00b72^1+ 1\u00b72^0)\\) -1 111 -11 sim -00 \\(-(0\u00b72^1+ 0\u00b72^0)\\) -0 <p></p> <p>Por fim, a forma mais utilizada \u00e9 complemento de dois. Nela, tamb\u00e9m o bit mais a esquerda define o sinal e os demais determinam o valor conforme o sinal. Se positivo, os bits restantes indicam o valor pela nota\u00e7\u00e3o posicional; se negativo, \u00e9 preciso inverter todos os bits e incrementar em 1 o resultado antes de considerar a nota\u00e7\u00e3o posicional. Embora mais complicada para n\u00f3s, esta abordagem tem vantagens sobre as demais, como quantidade de valores distintos que se pode armazenar e facilidade na computa\u00e7\u00e3o de opera\u00e7\u00f5es aritm\u00e9ticas.</p> <p> bits sinal inverte? +1 nota\u00e7\u00e3o posicional decimal 000 +00 n\u00e3o +00 n\u00e3o +00 \\(+(0\u00b72^1+ 0\u00b72^0)\\) +0 001 +01 n\u00e3o +01 n\u00e3o +01 \\(+(0\u00b72^1+ 1\u00b72^0)\\) +1 010 +10 n\u00e3o +10 n\u00e3o +10 \\(+(1\u00b72^1+ 0\u00b72^0)\\) +2 011 +11 n\u00e3o +11 n\u00e3o +11 \\(+(1\u00b72^1+ 1\u00b72^0)\\) +3 100 -00 sim -11 sim -100 \\(-(1\u00b72^2+ 0\u00b72^1+ 0\u00b72^0)\\) -4 101 -01 sim -10 sim -011 \\(-(0\u00b72^2+ 1\u00b72^1+ 1\u00b72^0)\\) -3 110 -10 sim -01 sim -010 \\(-(0\u00b72^2+ 1\u00b72^1+ 0\u00b72^0)\\) -2 111 -11 sim -00 sim -001 \\(-(0\u00b72^2+ 0\u00b72^1+ 1\u00b72^0)\\) -1 <p></p> <p>Geralmente, valores inteiros s\u00e3o armazenados em um tipo de dado <code>inteiro</code> de 32 ou 64 bits. Considerando o primeiro caso, a estrutura de dados para complemento de dois determina:</p> <ol> <li>O significado \u00e9 de um valor num\u00e9rico inteiro, que pode ser negativo.</li> <li>O valor \u00e9 armazenado como Complemento de 2 nos 32 bits.</li> <li>Os poss\u00edveis valores armazenados est\u00e3o no intervalo \\([-2^{31}, 2^{31})\\).</li> <li>As opera\u00e7\u00f5es aritm\u00e9ticas b\u00e1sicas (\\(+, -, \\times\\ e\\ \\div\\)) est\u00e3o definidas na linguagem de programa\u00e7\u00e3o - e possivelmente outras.</li> </ol>"},{"location":"programacao/#numeros-reais","title":"N\u00fameros Reais","text":"<p>Os n\u00fameros reais tamb\u00e9m podem ser representados como bin\u00e1rios pelo sistema posicional, basta estender a l\u00f3gica da nota\u00e7\u00e3o posicional. Por exemplo, considere o seguinte n\u00famero decimal:</p> \\[13,125 = 1\\cdot{10^1} + 3\\cdot{10^0} + 1\\cdot{10^{-1}} + 2\\cdot{10^{-2}} + 5\\cdot{10^{-3}}\\] <p>Este valor pode ser representado com a mesma l\u00f3gica em 7 bits:</p> \\[1\\cdot2^3 + 1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 0\\cdot2^{-2} + 1\\cdot2^{-3} = 1101,001_2\\] <p>Neste caso usamos 4 bits para o valor inteiro e 3 para o valor fracion\u00e1rio.</p> Ponto Fixo <p>A representa\u00e7\u00e3o com ponto fixo define que, dada uma quantidade \\(Q\\) de bits para representar o n\u00famero, h\u00e1 uma quantidade fixa \\(m\\) de bits que armazenam a parte inteira e outra quantidade \\(f\\) que armazena a parte fracion\u00e1ria do n\u00famero (tais que \\(Q = m + f\\)). Por exemplo, supondo \\(Qm.f = Q5.3\\), o n\u00famero 13,125 seria representado pelos bits <code>01101001</code> cujo valor \u00e9 interpretado como <code>01101,001</code>. Supondo \\(Q4.4\\), este mesmo valor \u00e9 representado por <code>11010010</code>.</p> <p>O ponto fixo \u00e9 uma conven\u00e7\u00e3o interessante, mas pouco flex\u00edvel. Como toda estrutura de dados, a quantidade de bits limita os valores que podem ser armazenado, portanto uma configura\u00e7\u00e3o \\(Qm.f\\) que pode ser adequada para uma aplica\u00e7\u00e3o espec\u00edfica pode ser inadequada para outra. Por exemplo, considerando que \\(Q=8\\), uma representa\u00e7\u00e3o \\(Q0.7\\) \u00e9 mais interessante para lidar com o tamanho de componentes eletr\u00f4nicos que a \\(Q5.3\\). Desta forma, fica invi\u00e1vel determinar um padr\u00e3o para ponto fixo que seja suficiente para a maioria das aplica\u00e7\u00f5es.</p> Ponto Flutuante <p>Como alternativa mas flex\u00edvel, temos a representa\u00e7\u00e3o em ponto flutuante que se baseia na ideia da nota\u00e7\u00e3o cient\u00edfica onde qualquer n\u00famero pode ser representado no mesmo formato em duas componentes, separando valor num\u00e9rico de sua grandeza. Dada uma mantissa (\\(m\\)) composta por algarismos que determinam o valor do n\u00famero e um expoente (\\(e\\)) que determina sua grandeza, um n\u00famero qualquer na base \\(B\\) pode ser representado da seguinte forma:</p> \\[m\\cdot{B}^{e}\\] <p>Por exemplo:</p> \\[0,13125\\cdot10^2 = 13,125_{10} \\Longleftrightarrow 1101,001_2 = 0,1101001\\cdot2^4\\] <p>Esta representa\u00e7\u00e3o oferece maior flexibilidade e alcance de valores. O padr\u00e3o usado nos computadores modernos \u00e9 o IEEE 754, que define o valor armazenado considerando um conjunto de bits de tamanho fixo em tr\u00eas partes: um bit para determinar o sinal, seguido de \\(e\\) bits para o valor do expoente, seguido de \\(m\\) bits para a mantissa. Esta abordagem permite que se use quaisquer quantidades de bits mas usualmente temos a precis\u00e3o simples (32 bits em blocos de 1/8/23) e dupla (64 bits, em blocos de 1/11/52). O valor armazenado pode ser obtido pelo valor num\u00e9rico simples de cada bloco desta forma:</p> \\[(-1)^{s}\\cdot1,m\\cdot2^{e-offset}\\] <p>O offset depende da quantidade de bits de e, sendo calculado como \\(2^{e-1}-1\\). Para as precis\u00f5es simples e dupla, temos os valores 127 e 1023, respectivamente. Por exemplo, para precis\u00e3o simples temos que:</p> sinal expoente mantissa f\u00f3rmula valor 1 01111110 10000000000000000000000 \\((-1)^{1}\\cdot1,1\\cdot2^{-1}\\) \\(-0,75_{10}\\) 0 10000010 10100100000000000000000 \\((-1)^{0}\\cdot1,101001\\cdot2^3\\) \\(13,125_{10}\\) <p>O uso de ponto flutuante oferece diversas vantagens, principalmente a representa\u00e7\u00e3o de valores absolutos muito grandes ou pequenos5, mas h\u00e1 limita\u00e7\u00f5es. O conjunto de n\u00fameros reais \u00e9 infinitamente grande, e n\u00e3o pode ser completamente representado com a quantidade finita de bits dispon\u00edvel na mem\u00f3ria, portanto \u00e9 muito comum que valores em ponto flutuante sejam arredondados ao serem armazenados na quantidade fixa de bits dispon\u00edvel6.</p> <p>Por exemplo, considere a express\u00e3o \\(1 / 3 = 0,33333\\dots\\). O valor resultante \u00e9 uma d\u00edzima peri\u00f3dica, podemos mostrar matematicamente que \\(0,\\overline{3} + 0,\\overline{3} + 0,\\overline{3} = 1\\). Entretanto, \\(0,\\overline{3}\\) \u00e9 uma express\u00e3o matem\u00e1tica com mais informa\u00e7\u00e3o que \"apenas\" algarismos, ela determina um valor que n\u00e3o pode ser exatamente representado por uma quantidade fixa de algarismos (ou bits na mem\u00f3ria). O que se pode fazer \u00e9 usar toda a capacidade dispon\u00edvel para armazenar o valor mais pr\u00f3ximo poss\u00edvel. Considere que s\u00f3 podemos usar 3 algarismos, ent\u00e3o a express\u00e3o \\(0,\\overline{3} + 0,\\overline{3} + 0,\\overline{3}\\) se torna \\(0,33 + 0,33 + 0,33 = 0,99 \\neq 1\\).</p> <p>Esta imprecis\u00e3o tem implica\u00e7\u00f5es interessantes pois, para um programa de computador, a express\u00e3o \\(0,1 + 0,1 + 0,1\\) n\u00e3o resulta no valor \\(0,3\\)! O valor decimal \\(0,1\\) \u00e9 representado em bin\u00e1rio como \\(0,1\\overline{0011}\\) at\u00e9 o limite de bits reservados, que \u00e9 insuficiente para o valor exato. Abaixo, podemos ver as diferen\u00e7as escolhendo precis\u00f5es arbitr\u00e1rias para mostrar um mesmo valor armazenado de \\(0,1\\), bem como o efeito da propaga\u00e7\u00e3o desta diferen\u00e7a ao longo de diversas opera\u00e7\u00f5es:</p> ValorSomat\u00f3rio <p><p>1 casa de precis\u00e3o: 0.1</p> <p>5 casas de precis\u00e3o: 0.10000</p> <p>15 casas de precis\u00e3o: 0.100000000000000</p> <p>28 casas de precis\u00e3o: 0.1000000000000000055511151231</p> </p> <p><p>\\(\\sum\\limits_{i=1}^{1}0.1 = 0.1000000000000000055511151231\\)</p> <p>\\(\\sum\\limits_{i=1}^{3}0.1 = 0.3000000000000000444089209850\\)</p> <p>\\(\\sum\\limits_{i=1}^{10}0.1 = 1.0000000000000000000000000000\\)</p> <p>\\(\\sum\\limits_{i=1}^{100}0.1 = 10.0000000000000000000000000000\\)</p> </p> <p>Os efeitos da imprecis\u00e3o tendem a n\u00e3o ser considerados na maioria das aplica\u00e7\u00f5es (que n\u00e3o lidem com isso como as de engenharia/finan\u00e7as/computa\u00e7\u00e3o cient\u00edfica). Entretanto, deve-se ter aten\u00e7\u00e3o especial pois, apesar da diferen\u00e7a para o valor exato ser \"pequena\", ela existe e pode causar dificuldades se seu programa liga com algo simples como verificar se \\(0,1 + 0,2 = 0,3\\) (algo bem prov\u00e1vel de ocorrer em muitas aplica\u00e7\u00f5es). \u00c9 papel do programador entender a situa\u00e7\u00e3o e lidar com ela.</p> <p>Algumas abordagens para com isso s\u00e3o trabalhar com inteiros e evitar comparar diretamente vari\u00e1veis do tpo <code>float</code>. Se necess\u00e1rio, podemos realizar a compara\u00e7\u00e3o considerando uma toler\u00e2ncia razo\u00e1vel para a diferen\u00e7a entre os valores: ao inv\u00e9s de \\(a &lt; b\\), usamos \\(|a - b| &lt; \\epsilon\\). Tamb\u00e9m \u00e9 preciso atentar para ac\u00famulo de imprecis\u00f5es ao longo de m\u00faltiplas computa\u00e7\u00f5es, pois podem ser realmente significativos.</p> Resumo <p></p> Llm <ul> <li>Explique o conceito de tipo de dados em programa\u00e7\u00e3o.</li> <li>Explique \"complemento de 2\" na programa\u00e7\u00e3o de computadores.</li> <li>Como funciona o padr\u00e3o IEEE754?</li> <li>Por que usar int se float pode representar valores inteiros?</li> <li>Por que \u00e9 preciso cuidado a usar o tipo de dados float?</li> <li>O que s\u00e3o estruturas de dados?</li> </ul> Exerc\u00edcios Dado um n\u00famero n\u00e3o negativo qualquer na base hexadecimal, descreva o algoritmos para transform\u00e1-lo em um n\u00famero bin\u00e1rio. <p>Como a base 16 \u00e9 m\u00faltipla de 2, o processo manual \u00e9 bem simples. Cada algarismo hexadecimal pode ser diretamente mapeado para seu valor bin\u00e1rio de 4 bits, na mesma ordem. Por exemplo, para \\(2A_{16}\\) temos que \\(2_{16} \\rightarrow 0010_2\\) e \\(A_{16} \\rightarrow 1010_2\\), portanto \\(2A_{16}\\rightarrow 00101010_2\\).</p>"},{"location":"programacao/#simbolos","title":"S\u00edmbolosResumoExerc\u00edcios","text":"<p>S\u00edmbolos s\u00e3o uma forma extremamente vers\u00e1til de comunicar informa\u00e7\u00f5es; o alfabeto define um pequeno conjunto de s\u00edmbolos que, juntos, podem expressar quase tudo que se deseja. S\u00edmbolos, como toda informa\u00e7\u00e3o no computador, s\u00e3o representados por bits.</p> ASCII <p>O padr\u00e3o ASCII7 (American Standard Code for Information Interchange) foi desenvolvido nos anos 60, sendo composto por 95 s\u00edmbolos gr\u00e1ficos (letras do alfabeto latino, algarismos ar\u00e1bicos, sinais de pontua\u00e7\u00e3o e sinais matem\u00e1ticos) e 33 de controle.</p> <p> Controle bits S\u00edmbolo bits S\u00edmbolo bits S\u00edmbolo bits S\u00edmbolo 0x00 NUL 0x08 BS 0x10 DLE 0x18 CAN 0x01 SOH 0x09 HT 0x11 DC1 0x19 EM 0x02 STX 0x0A LF 0x12 DC2 \u22ee \u22ee 0x03 ETX 0x0B VT 0x13 DC3 \u22ee \u22ee 0x04 EOT 0x0C FF 0x14 DC4 \u22ee \u22ee 0x05 ENQ 0x0D CR 0x15 NAK \u22ee \u22ee 0x06 ACK 0x0E SO 0x16 SYN \u22ee \u22ee 0x07 BEL 0x0F SI 0x17 ETB 0x7F DEL Gr\u00e1ficos (Parcial) bits S\u00edmbolo bits S\u00edmbolo bits S\u00edmbolo bits S\u00edmbolo 0x20 espa\u00e7o 0x30 0 0x41 A 0x61 a 0x21 ! 0x31 1 0x42 B 0x62 b 0x22 \" 0x32 2 0x43 C 0x63 c 0x23 # 0x33 3 0x44 D 0x64 d 0x24 $ 0x34 4 0x45 E 0x65 e 0x25 % 0x35 5 \u22ee \u22ee \u22ee \u22ee 0x26 &amp; 0x36 6 0x57 W 0x77 w 0x27 ' 0x37 7 0x58 X 0x78 x 0x28 ( 0x38 8 0x59 Y 0x79 y 0x29 ) 0x39 9 0x5A Z 0x7A z \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee <p></p> <p>Cada um dos 128 s\u00edmbolos \u00e9 associado \u00e0 uma sequ\u00eancia arbitr\u00e1ria e \u00fanica de 7 de bits. \u00c9 bem comum associar esta sequ\u00eancia a um n\u00famero inteiro, por exemplo o n\u00famero 65 ao s\u00edmbolo 'A' (\"um mesmo conjunto de bits pode ser interpretado de diferentes formas\"). Al\u00e9m disso, o padr\u00e3o ASCII tem algumas caracter\u00edsticas interessantes. Os algarismos s\u00e3o listados em ordem de valor, e as letras s\u00e3o organizadas em ordem alfab\u00e9tica, o que facilita os processos de compara\u00e7\u00e3o entre eles. As letras min\u00fasculas est\u00e3o deslocadas em 32 posi\u00e7\u00f5es em rela\u00e7\u00e3o \u00e0s mai\u00fasculas, ent\u00e3o a diferen\u00e7a entre os bits que as representam \u00e9 apenas no sexto bit!</p> <p>Por conta de como as m\u00e1quinas eram constru\u00eddas, era muito comum usar um byte para armazenar cada s\u00edmbolo, o que viabilizou definir outros 128 s\u00edmbolos arbitr\u00e1rios. Entretanto, n\u00e3o houve maior consenso em quais seriam os s\u00edmbolos, afinal cada grupo tinha seus pr\u00f3prios interesses. No Brasil, o mais comum era o ISO/IEC 8859-1. Com o avan\u00e7o da internet, a necessidade de comunica\u00e7\u00e3o entre m\u00e1quinas e grupos distintos for\u00e7ou a incorpora\u00e7\u00e3o de um padr\u00e3o internacional. Entretanto, algumas dificuldades deveriam ser consideradas...</p> <p>Uma solu\u00e7\u00e3o \"simples\" seria usar mais bits e ampliar o tamanho da tabela, mas isso implicaria que toda informa\u00e7\u00e3o j\u00e1 representada num padr\u00e3o como ASCII ocuparia mais mem\u00f3ria que o necess\u00e1rio. Por exemplo, supondo que fossem usados 3 bytes (possibilitando mais de 16 milh\u00f5es de s\u00edmbolos), uma mensagem com 10 s\u00edmbolos ASCII passa a ocupar 30 bytes, 200% a mais do que necess\u00e1rio. Tamb\u00e9m seria necess\u00e1rio lidar com informa\u00e7\u00f5es armazenadas que usam o s\u00edmbolo <code>NUL</code> para indicar o t\u00e9rmino de uma sequ\u00eancia de s\u00edmbolos - uma sequ\u00eancia de 8 bits com valor 0 n\u00e3o seria rara considerando 3 bytes. Outro ponto relevante era lidar com os documentos existentes, gerar uma c\u00f3pia de todo arquivo existente com esta nova codifica\u00e7\u00e3o seria uma tarefa invi\u00e1vel. A solu\u00e7\u00e3o encontrada foi uma forma elegante de lidar com tudo isso, al\u00e9m de viabilizar a incorpora\u00e7\u00e3o de quaisquer novos s\u00edmbolos que possam ser criados.</p> Unicode <p>Uma vez estabelecido um padr\u00e3o de codifica\u00e7\u00e3o de caracteres (associa\u00e7\u00e3o [arbitr\u00e1ria] de bits a certos caracteres), pode-se armazenar estes s\u00edmbolos na mem\u00f3ria (e recuper\u00e1-los). H\u00e1 diversar formas de se codificar caracteres: EBCDIC, Unicode (veja isso), ente outros.</p> <p></p> Llm <ul> <li>Explique o conceito de tipo de dados em programa\u00e7\u00e3o.</li> <li>Explique o padr\u00e3o ASCII.</li> <li>Explique o padr\u00e3o UniCode.</li> <li>Quais as vantagens do padr\u00e3o UTF-8?</li> <li>Como compactar dados UTF-8  para comunica\u00e7\u00e3o em rede?</li> </ul> <p></p>"},{"location":"programacao/#booleanos","title":"BooleanosResumoExerc\u00edcios","text":"Llm"},{"location":"programacao/#fluxo-de-controle","title":"Fluxo de Controle","text":""},{"location":"programacao/#sequencial","title":"Sequencial","text":""},{"location":"programacao/#funcoes","title":"Fun\u00e7\u00f5es","text":"<p>Joe Sondow</p> <p>Um computador \u00e9 como um g\u00eanio travesso. Te d\u00e1 exatamente o que voc\u00ea pede dele, mas nem sempre o que voc\u00ea quer.</p> <p>Programas de computadores geralmente usam procedimentos que especificam como fazer algo8. Nas linguagens de programa\u00e7\u00e3o, estes s\u00e3o chamados de fun\u00e7\u00f5es (ou m\u00e9todos), e s\u00e3o chamados para serem executados. Ao chamar um procedimento, pode-se fornecer informa\u00e7\u00f5es necess\u00e1rias para a computa\u00e7\u00e3o ao definir par\u00e2metros, e receber (ou n\u00e3o) resultados como um valor de retorno.</p> Chat-bot Fun\u00e7\u00f5es <ul> <li>O que \u00e9 uma fun\u00e7\u00e3o em programa\u00e7\u00e3o?</li> <li>Quais as vantagens de usar fun\u00e7\u00f5es em um programa?</li> <li>O que \u00e9 o escopo de uma fun\u00e7\u00e3o?</li> <li>Quais os componentes de uma fun\u00e7\u00e3o em Python?</li> <li>Quais as fun\u00e7\u00f5es mais \u00fateis em Python?</li> </ul>"},{"location":"programacao/#condicional","title":"Condicional","text":"<p>exemplo do imc (implica\u00e7\u00f5es matem\u00e1ticas de se n\u00e3o \u00e9 &lt; x, necessariamente \u00e9 &gt;= x)</p> \u00cdndice de Massa Corporal<pre><code>def avalia_imc(m, h):\nimc = calcula_imc(m, h)\nif imc &lt; 18.5:\nprint('Situa\u00e7\u00e3o de magreza!')\nelif imc &lt; 25:\nprint('Situa\u00e7\u00e3o normal.')\nelif imc &lt; 30:\nprint('Situa\u00e7\u00e3o de sobrepeso.')\nelif imc &lt; 40:\nprint('Situa\u00e7\u00e3o de obesidade!')\nelse:\nprint('Situa\u00e7\u00e3o de obesidade grave!!')\n</code></pre> <p>O uso de condicionais \u00e9 baseado no valores booleanos \\(verdadeiro\\) e \\(falso\\). Estes s\u00e3o os valores verdade da l\u00f3gica matem\u00e1tica, e indicam o grau de verdade de uma proposi\u00e7\u00e3o. Por exemplo, considerando os n\u00fameros inteiros 42 e 100, podemos a propor que \\(42 &lt; 100\\) e verificar que isto \u00e9 verdadeiro. As linguagens de programa\u00e7\u00e3o podem oferecer um tipo de dado espec\u00edfico para estes valores ou interpretar outros tipos de dados como um dos dois resultados poss\u00edveis. Por exemplo, a linguagem C n\u00e3o tem um tipo primitivo e interpreta o valor num\u00e9rico zero como o valor booleano \\(falso\\), e qualquer valor diferente disso como \\(verdadeiro\\). J\u00e1 Python tem o tipo bool, mas tamb\u00e9m interpreta uma s\u00e9rie de outros tipos de dados.</p> <p><code>&lt;expr&gt;</code> \u00e9 uma express\u00e3o cujo valor resultante tem um significado booleano, ou seja, \u00e9 verdadeiro ou falso.</p> <p>Se <code>&lt;expr&gt;</code> \u00e9 verdadeiro (\"truthy\"), ent\u00e3o <code>&lt;instr&gt;</code> \u00e9 executada; caso contr\u00e1rio, <code>&lt;instr&gt;</code> \u00e9 ignorada.</p> PythonC Estrutura condicional<pre><code>if &lt;expr&gt;:\n&lt;instr&gt;\n</code></pre> Estrutura condicional<pre><code>if (&lt;expr&gt;) {\n&lt;instr&gt;;\n}\n</code></pre> Chat-bot Condicionais <ul> <li>Explique a estrutura condicional no fluxo de controle de um programa.</li> <li>Explique os operadores l\u00f3gicos em Python.</li> <li>Como portas l\u00f3gicas comp\u00f5em uma CPU?</li> <li>O que \u00e9 curto-circuito em Python?</li> </ul>"},{"location":"programacao/#repeticao","title":"Repeti\u00e7\u00e3o","text":"Chat-bot Repeti\u00e7\u00e3o <ul> <li>Explique as estruturas de repeti\u00e7\u00e3o no fluxo de controle de um programa.</li> <li>Quais as diferen\u00e7as entre while e for em Python?</li> <li>D\u00ea um exemplo de c\u00f3digo em que while seja prefer\u00edvel ao for.</li> <li>D\u00ea um exemplo de c\u00f3digo em que for seja prefer\u00edvel ao while</li> </ul> Resumo Chat-bot Fluxo de Controle <ul> <li>O que \u00e9 o fluxo de controle de um programa?</li> </ul> Exerc\u00edcios Implemente o c\u00f3digo que leia a quantidade m\u00e1xima N de elefantes e apresente a letra da m\u00fasica at\u00e9 que N (\u22651) elefantes incomodem muita gente. Por exemplo, para N = 4: 1 elefante incomoda muita gente... 2 elefantes incomodam, incomodam muito mais! 2 elefantes incomodam muita gente... 3 elefantes incomodam, incomodam, incomodam muito mais! 3 elefantes incomodam muita gente... 4 elefantes incomodam, incomodam, incomodam, incomodam muito mais! <p>Uma poss\u00edvel solu\u00e7\u00e3o \u00e9: Elefantes<pre><code>n = int(input('Digite a quantidade de elefantes: '))\nprint('1 elefante incomoda muita gente...')\nprint('2 elefantes incomodam, incomodam muito mais!')\nfor e in range(2, n):\nprint(f'{e} elefantes incomodam muita gente...')\nincomodam = ', incomodam' * e\nprint(f'{e + 1} elefantes incomodam{incomodam} muito mais!')\n</code></pre></p> Considerando um comprimento L, implemente o c\u00f3digo que desenha um quadrado de lado L. <p>Uma poss\u00edvel solu\u00e7\u00e3o \u00e9: Quadrado<pre><code>from tartaruga import *\nfor _ in range(4):\nfrente(L)\ndireita(90)\n</code></pre></p> <ol> <li> <p>Peter Norvig. Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1st edition, 1992. ISBN 1558601910. URL: https://github.com/norvig/paip-lisp.\u00a0\u21a9\u21a9</p> </li> <li> <p>Charles Russell Severance, Sue Blumenberg, and Elliott Hauser. Python for Everybody: Exploring Data in Python 3. CreateSpace Independent Publishing Platform, USA, 2016. ISBN 1530051126, 9781530051120.\u00a0\u21a9</p> </li> <li> <p>Harold Abelson, Gerald Jay Sussman, and Julie Sussman. Structure and Interpretation of Computer Programs. MIT Press, Cambridge, MA, USA, 1985. ISBN 0262010771.\u00a0\u21a9</p> </li> <li> <p>Brian W. Kernighan and Dennis M. Ritchie. C: a linguagem de programa\u00e7\u00e3o padr\u00e3o ANSI. Campus, Rio de Janeiro, 1989. ISBN 8570015860 9788570015860.\u00a0\u21a9</p> </li> <li> <p>Aaron M Tenenbaum, Yedidyah Langsam, and Moshe Augenstein. Estruturas de dados usando C. Pearson Makron Books, S\u00e3o Paulo (SP), 1995. ISBN 8534603480 : 9788534603485.\u00a0\u21a9</p> </li> <li> <p>David Goldberg. What every computer scientist should know about floating-point arithmetic. ACM Comput. Surv., 23(1):5\u201348, mar 1991. URL: https://doi.org/10.1145/103162.103163, doi:10.1145/103162.103163.\u00a0\u21a9</p> </li> <li> <p>American National Standards Institute. American National Standard for Information Systems \u2014 Coded Character Sets \u2014 7-Bit American National Standard Code for Information Interchange (7-Bit ASCII), ANSI X3.4-1986. Technical Report, American National Standards Institute, 1896. URL: http://sliderule.mraiow.com/w/images/7/73/ASCII.pdf.\u00a0\u21a9</p> </li> <li> <p>Thomas H. Cormen. Algorithms Unlocked. The MIT Press, 2013. ISBN 9780262518802. URL: https://mitpress.mit.edu/9780262518802/algorithms-unlocked/.\u00a0\u21a9</p> </li> </ol>"},{"location":"slides/pensamento_computacional/","title":"Pensamento Computacional","text":""},{"location":"slides/pensamento_computacional/#algoritmos-e-programacao-de-computadores","title":"Algoritmos e Programa\u00e7\u00e3o de Computadores","text":"<p>N\u00e3o podemos resolver um problema usando o mesmo tipo de pensamento que usamos quando os criamos.</p> <p>Albert Einstein</p> <p> </p>"},{"location":"slides/pensamento_computacional/#pensamento-computacional_1","title":"Pensamento Computacional","text":"<p>Processos de pensamento envolvidos em: * formular problemas, e * formular solu\u00e7\u00f5es realiz\u00e1veis.</p> <p>--</p> <ol> <li>Descrever o problema.</li> <li>Dividir o problema em uma sequ\u00eancia l\u00f3gica de pequenas tarefas.</li> <li>Identificar os detalhes relevantes para a solu\u00e7\u00e3o.</li> <li>Elaborar um processo de resolu\u00e7\u00e3o de cada tarefa (algoritmo).</li> <li>Avaliar este processo.</li> </ol>"},{"location":"slides/pensamento_computacional/#decomposicao","title":"Decomposi\u00e7\u00e3o","text":"<p>Redefini\u00e7\u00e3o do problema como partes menores e mais f\u00e1ceis (ou poss\u00edveis) de se lidar.</p> <p>--</p> <p>Fa\u00e7a um bolo. 1. Junte os ingredientes.  1. Misture.  1. Unte a forma.  1. Despeje a massa na forma. </p>"},{"location":"slides/pensamento_computacional/#reconhecimento-de-padroes","title":"Reconhecimento de Padr\u00f5es","text":"<p>Perceber similaridades entre problema (ou partes) para criar uma solu\u00e7\u00e3o adequada \u00e0 classe do problema ( e n\u00e3o s\u00f3 a uma ocorr\u00eancia).</p> <p>--</p>"},{"location":"slides/pensamento_computacional/#numeros-primos","title":"N\u00fameros Primos","text":"<p>2, 3, 5, 7, 11, ...</p> <p>..., 13, 17, 19 </p> <p>--</p>"},{"location":"slides/pensamento_computacional/#generalizacao-de-padroes","title":"Generaliza\u00e7\u00e3o de Padr\u00f5es","text":"<p>Criar modelos/regras/princ\u00edpios gen\u00e9ricos a partir de padr\u00f5es observados em inst\u00e2ncias espec\u00edficas do problema.</p> <p>--</p>"},{"location":"slides/pensamento_computacional/#par-1-impar","title":"par + 1 = \u00edmpar","text":"<p><code>0 + 1   = 1</code></p> <p><code>2 + 1   = 3</code></p> <p><code>4 + 1   = 5</code></p> <p><code>\u22ee</code></p>"},{"location":"slides/pensamento_computacional/#abstracao","title":"Abstra\u00e7\u00e3o","text":"<p>Identificar e focar nos aspectos fundamentais do problema, ignorando as especificidades.</p> <p>--</p>"},{"location":"slides/pensamento_computacional/#realidade-abstracao","title":"Realidade \u2192 Abstra\u00e7\u00e3o","text":""},{"location":"slides/pensamento_computacional/#pensamento-algoritmico","title":"Pensamento Algor\u00edtmico","text":"<p>Processo de criar algoritmos (como solu\u00e7\u00f5es).</p> <p>Um algoritmo \u00e9 a descri\u00e7\u00e3o dos passos para realizar uma tarefa.</p> <p>--</p> <p>Se tiver um mapa e os pontos de origem e destino, posso decompor o trajeto entre eles em trechos menores e definir rotas entre eles, e depois junt\u00e1-las numa rota final. Posso usar este processo para tra\u00e7ar uma rota entre quaisquer origem/destino!</p> <p>--</p>"},{"location":"slides/pensamento_computacional/#automacao","title":"Automa\u00e7\u00e3o","text":"<p>Uso de mecanismos para realiza\u00e7\u00e3o de um algoritmo.</p> <p>--</p> <p> </p> <p>Produ\u00e7\u00e3o, produtividade, efici\u00eancia, uniformidade, qualidade, libera\u00e7\u00e3o de recurso humano, etc.</p> <p>--</p>"},{"location":"slides/pensamento_computacional/#avaliacao","title":"Avalia\u00e7\u00e3o","text":"<p>Dentre as poss\u00edveis solu\u00e7\u00f5es, considere: - Qual a mais adequada? - Em que contextos ela funciona (ou n\u00e3o)? - Como \u00e9 seu desempenho?</p> <p>--</p>"},{"location":"slides/pensamento_computacional/#encontrar-a-pagina-p-em-um-livro","title":"Encontrar a p\u00e1gina P em um livro","text":"<p>\ud83d\ude2b Feche os olhos.</p> <p>\ud83d\ude10 Enquanto n\u00e3o encontrar a p\u00e1gina P, escolha uma p\u00e1gina qualquer.</p> <p>\ud83d\ude0c Escolha a 1a p\u00e1gina. Enquanto a escolhida n\u00e3o for P, escolha a p\u00e1gina seguinte.</p> <p>\ud83d\ude00 Escolha a p\u00e1gina do meio. Se for P, pare. Se for maior que P, descarte-a e todas as p\u00e1ginas anteriores. Caso contr\u00e1rio, descarte-a e todas as posteriores. Repita este processo.</p>"},{"location":"slides/pensamento_computacional/#resumo","title":"Resumo","text":"<ul> <li>Pensamento computacional visa formular solu\u00e7\u00f5es para problemas para que possam ser realizadas por um agente.</li> <li>Envolve conceitos de  decomposi\u00e7\u00e3o, abstra\u00e7\u00e3o, reconhecimento de padr\u00f5es, pensamento algor\u00edtmico e avalia\u00e7\u00e3o.</li> </ul>"},{"location":"slides/programacao/","title":"Programa\u00e7\u00e3o","text":""},{"location":"slides/programacao/#algoritmos-e-programacao-de-computadores","title":"Algoritmos e Programa\u00e7\u00e3o de Computadores","text":""},{"location":"slides/programacao/#programacao_1","title":"Programa\u00e7\u00e3o","text":"<p>Processo de expressar um algoritmo como instru\u00e7\u00f5es em uma linguagem de programa\u00e7\u00e3o.</p> <p>--</p> <p>Programa\u00e7\u00e3o de computadores \u00e9 muito divertida. Como m\u00fasica, \u00e9 uma habilidade originada em um talento desconhecido e pr\u00e1tica constante.</p> <p>Larry O\u2019Brien &amp; Bruce Eckel</p>"},{"location":"slides/programacao/#linguagens","title":"Linguagens","text":"Animal Humana  Programa\u00e7\u00e3o  \ud83d\udc41 Portugu\u00eas  Python  \ud83d\udc4b English  C / C++  \ud83d\udc43 \u65e5\u672c\u8a9e    Assembly  \ud83d\udc42 \u0627\u064e\u0644\u0652\u0639\u064e\u0631\u064e\u0628\u0650\u064a\u064e\u0651\u0629\u064f  \u0627 Haskell  \ud83d\uddf2 \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a  LISP  <p>--</p>"},{"location":"slides/programacao/#linguagem-de-programacao","title":"Linguagem de Programa\u00e7\u00e3o","text":"<ul> <li>Vocabul\u00e1rio</li> <li>Gram\u00e1tica:</li> <li>regras sint\u00e1ticas</li> <li>regras sem\u00e2nticas</li> </ul> <p>--</p>"},{"location":"slides/programacao/#codigo-fonte","title":"C\u00f3digo-Fonte","text":"<p>Um algoritmo expresso como instru\u00e7\u00f5es para o computador.</p> <p>--</p>"},{"location":"slides/programacao/#linguagem-de-maquina","title":"Linguagem de M\u00e1quina","text":"<p>Aquela que o hardware [espec\u00edfico] entende (c\u00f3digo bin\u00e1rio).</p> <p>--</p>"},{"location":"slides/programacao/#codigo-binario","title":"C\u00f3digo Bin\u00e1rio","text":"<pre><code>0111 1111 0100 0101 0100 1100 0100 0110\n0000 0010 0000 0001 0000 0001 0000 0000\n0000 0000 0000 0000 0000 0000 0000 0000\n0000 0000 0000 0000 0000 0000 0000 0000\n0000 0010 0000 0000 0011 1110 0000 0000\n0000 0001 0000 0000 0000 0000 0000 0000\n0100 0000 0000 0100 0100 0000 0000 0000\n0000 0000 0000 0000 0000 0000 0000 0000\n(continua por mais 2120 linhas)\n</code></pre> <p>--</p>"},{"location":"slides/programacao/#linguagem-de-baixo-nivel","title":"Linguagem de Baixo N\u00edvel","text":"<p>Usam instru\u00e7\u00f5es mnem\u00f4nicas para tentar facilitar a programa\u00e7\u00e3o.</p> <p>--</p>"},{"location":"slides/programacao/#assembly","title":"Assembly","text":"<pre><code>section .data\nmsg     db      'Ola mundo!', 0AH\nlen     equ     $-msg\n\nsection .text\nglobal  _start\n_start: mov     edx, len\n        mov     ecx, msg\n        mov     ebx, 1\n        mov     eax, 4\n        int     80h\n\n        mov     ebx, 0\n        mov     eax, 1\n        int     80h\n</code></pre> <p>--</p>"},{"location":"slides/programacao/#linguagem-de-alto-nivel","title":"Linguagem de Alto N\u00edvel","text":"<p>Usa um vocabul\u00e1rio mais rico para facilitar programa\u00e7\u00e3o.</p> <p>--</p>"},{"location":"slides/programacao/#c","title":"C","text":"<pre><code>#include &lt;stdio.h&gt;\nint main() {\nprintf(\"Ola mundo!\\n\");\nreturn 0;\n}\n</code></pre>"},{"location":"slides/programacao/#python","title":"Python","text":"<pre><code>print('Ola mundo!')\n</code></pre> <p>--</p>"},{"location":"slides/programacao/#python_1","title":"Python","text":"<ul> <li>F\u00e1cil de aprender</li> <li>Gratuita e de c\u00f3digo livre</li> <li>Linguagem de alto n\u00edvel\u200b</li> <li>Interpretada\u200b</li> <li>Portabilidade\u200b</li> </ul> <p>--</p> <p> </p> <p>--</p>"},{"location":"slides/programacao/#interpretador-python","title":"Interpretador Python","text":"<pre><code>Python 3.8.10 (default, Nov 22 2023, 10:22:35)\n[GCC 9.4.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt;\n</code></pre>"},{"location":"slides/programacao/#instrucoes","title":"Instru\u00e7\u00f5es","text":"<p>Unidades v\u00e1lidas de c\u00f3digo-fonte.</p> <p>(que realizam algo)</p> <p></p> <pre><code>linguagem = 'Python'\n</code></pre> <p>--</p>"},{"location":"slides/programacao/#expressoes","title":"Express\u00f5es","text":"<p>Instru\u00e7\u00f5es que resultam em um valor.</p> <p>(que s\u00e3o algo)</p> <pre><code>&gt;&gt;&gt; 2 + 40\n42\n</code></pre> <pre><code>&gt;&gt;&gt; ((16 - 1) + (12 / 2)) * 2\n42.0\n</code></pre> <p>--</p>"},{"location":"slides/programacao/#python-com-numeros","title":"Python com n\u00fameros","text":"<pre><code>&gt;&gt;&gt; 2 + 2\n4\n&gt;&gt;&gt; 50 - 5 * 6\n20\n&gt;&gt;&gt; (50 - 5 * 6) / 4\n5.0\n&gt;&gt;&gt; 8 / 5\n1.6\n</code></pre> <p>--</p>"},{"location":"slides/programacao/#python-com-numeros_1","title":"Python com n\u00fameros","text":"<pre><code>&gt;&gt;&gt; 17 / 3\n5.666666666666667\n&gt;&gt;&gt; 17 // 3\n5\n&gt;&gt;&gt; 17 % 3\n2\n&gt;&gt;&gt; 5 * 3 + 2\n17\n</code></pre> <p>--</p>"},{"location":"slides/programacao/#python-com-texto","title":"Python com texto","text":"<pre><code>&gt;&gt;&gt; ' Ni! '  # aspas simples\n' Ni! '\n&gt;&gt;&gt;\n&gt;&gt;&gt; \"Estou sendo oprimido!\"  # aspas duplas\n'Estou sendo oprimido!'\n&gt;&gt;&gt;\n&gt;&gt;&gt; '\u00c9 \"s\u00f3\" um arranh\u00e3o...'  # ambas\n'\u00c9 \"s\u00f3\" um arranh\u00e3o...'\n</code></pre>"},{"location":"slides/programacao/#constantes","title":"Constantes","text":"<p>Valores fixos, como n\u00fameros ou s\u00edmbolos, que n\u00e3o s\u00e3o alterados ao longo da execu\u00e7\u00e3o do programa.</p> <p></p> <pre><code>&gt;&gt;&gt; 42\n42\n&gt;&gt;&gt; 3.14\n3.14\n&gt;&gt;&gt; \"Estou sendo oprimido!\"\n'Estou sendo oprimido!'\n</code></pre> <p>--</p> <p>\u00c9 poss\u00edvel armazenar um valor na mem\u00f3ria associando-o a um ~nome~ identificador \u00fanico.\u200b</p> <p></p> <pre><code>&gt;&gt;&gt; resposta_do_universo = 42\n&gt;&gt;&gt; pi = 3.14\n&gt;&gt;&gt; status = \"Estou sendo oprimido!\"\n</code></pre> <p>--</p> <p>\u00c9 poss\u00edvel acessar um valor armazenado na mem\u00f3ria pelo identificador associado.\u200b</p> <p></p> <pre><code>&gt;&gt;&gt; resposta_do_universo\n42\n&gt;&gt;&gt; pi\n3.14\n&gt;&gt;&gt; status\n'Estou sendo oprimido!'\n</code></pre>"},{"location":"slides/programacao/#variaveis","title":"Vari\u00e1veis","text":"<p>\u00c9 poss\u00edvel alterar valores armazenados.\u200b</p> <p></p> <pre><code>&gt;&gt;&gt; resposta_do_universo = pi\n&gt;&gt;&gt; resposta_do_universo\n3.14\n</code></pre> <p>--</p>"},{"location":"slides/programacao/#variaveis_1","title":"Vari\u00e1veis","text":"<p>O identificador associado a cada valor faz muita diferen\u00e7a no entendimento do programa.</p> <pre><code>&gt;&gt;&gt; xou87623 = xou87623 * xou37623\n&gt;&gt;&gt; xou87632 = xou37638 + xou37623 + xou87234 + xou87888\n&gt;&gt;&gt; f'Sobrou R${xou87623 - xou87632}!'\n</code></pre> <p>--</p>"},{"location":"slides/programacao/#variaveis_2","title":"Vari\u00e1veis","text":"<p>O identificador associado a cada valor faz muita diferen\u00e7a no entendimento do programa.</p> <pre><code>&gt;&gt;&gt; salario = salario * bonus\n&gt;&gt;&gt; gastos = eletricidade + gas + internet + mercado\n&gt;&gt;&gt; f'Sobrou R${salario - gastos}!'\n</code></pre>"},{"location":"slides/programacao/#atribuicao-igualdade","title":"Atribui\u00e7\u00e3o \u2260 Igualdade\u200b","text":"<p>A instru\u00e7\u00e3o <code>x = 42</code> significa \"atribua o valor 42 \u00e0 vari\u00e1vel x\", e n\u00e3o \"x \u00e9 igual a 42\".</p> <pre><code>&gt;&gt;&gt; x = 42\n&gt;&gt;&gt; 42 = x\nFile \"&lt;stdin&gt;\", line 1\nSyntaxError: cannot assign to literal\n</code></pre>"},{"location":"slides/programacao/#tipos-de-valores","title":"Tipos de Valores","text":"<p>Cada valor representa uma informa\u00e7\u00e3o, cujo significado depende do seu tipo.</p> <p>X </p>"},{"location":"slides/programacao/#tipos-de-valores_1","title":"Tipos de Valores","text":"<pre><code>&gt;&gt;&gt; type(42)\n&lt;class 'int'&gt;\n&gt;&gt;&gt; type(3.14)\n&lt;class 'float'&gt;\n&gt;&gt;&gt; type('Ni!')\n&lt;class 'str'&gt;\n</code></pre> <p>--</p>"},{"location":"slides/programacao/#tipos-de-valores_2","title":"Tipos de Valores","text":"<pre><code>&gt;&gt;&gt; type(1)\n&lt;class 'int'&gt;\n&gt;&gt;&gt; type(1.0)\n&lt;class 'float'&gt;\n&gt;&gt;&gt; type('1')\n&lt;class 'str'&gt;\n&gt;&gt;&gt; type('1.0')\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"slides/programacao/#erros-de-sintaxe","title":"Erros de Sintaxe","text":"<p>Causados por uma instru\u00e7\u00e3o inv\u00e1lida.</p> <p></p> <pre><code>21 vezes 2\nFile \"&lt;stdin&gt;\", line 1\n21 vezes 2\n^\nSyntaxError: invalid syntax\n</code></pre>"},{"location":"slides/programacao/#erros-de-semantica","title":"Erros de Sem\u00e2ntica","text":"<p>Causados por uma instru\u00e7\u00e3o v\u00e1lida mas em um contexto logicamente incorreto.</p> <p></p> <pre><code>42 / 0\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nZeroDivisionError: division by zero\n</code></pre>"},{"location":"slides/programacao/#programa","title":"Programa","text":"<p>Representa\u00e7\u00e3o de um algoritmo como c\u00f3digo-fonte.</p> <p>Algoritmo: sequ\u00eancia finita de instru\u00e7\u00f5es bem definidas e n\u00e3o amb\u00edguas para executar uma tarefa.</p> <p>--</p>"},{"location":"slides/programacao/#fluxo-de-controle","title":"Fluxo de Controle","text":"<p>Determina a ordem em que s\u00e3o executadas as instru\u00e7\u00f5es.</p> <ol> <li>Sequencial</li> <li>Condicional</li> <li>Repeti\u00e7\u00e3o</li> </ol> <p>--</p>"},{"location":"slides/programacao/#fluxo-sequencial","title":"Fluxo Sequencial","text":"<p>As instru\u00e7\u00f5es s\u00e3o executadas uma ap\u00f3s a outra, na mesma ordem em que se encontram na representa\u00e7\u00e3o.</p> <p>Necess\u00e1rio para garantir a corretude dos algoritmos.</p> <p>--</p> <ul> <li>Bata as claras em neve.</li> <li>Reserve.</li> <li>Bata bem as gemas com a margarina e o a\u00e7\u00facar.</li> <li>Acrescente o leite e a farinha aos poucos sem parar de bater. Por \u00faltimo agregue as claras em neve e o fermento.</li> <li>Coloque em forma grande de furo central untada e enfarinhada.</li> <li>Asse em forno m\u00e9dio, pr\u00e9-aquecido, por aproximadamente 40 min.</li> <li>Quando espetar um palito e sair limpo estar\u00e1 assado.</li> </ul>"},{"location":"slides/programacao/#resumo","title":"Resumo","text":"<ul> <li>Programa\u00e7\u00e3o: codifica\u00e7\u00e3o do algoritmo.</li> <li>Instru\u00e7\u00e3o: unidade v\u00e1lida de c\u00f3digo.</li> <li>Express\u00e3o: instru\u00e7\u00e3o que resulta em um valor.</li> <li>Tipo de dado: defini\u00e7\u00e3o de como armazenar/processar um valor armazenado na mem\u00f3ria\u200b.</li> <li>Vari\u00e1vel: nome de um valor armazenado na mem\u00f3ria.</li> <li>As instru\u00e7\u00f5es de um algoritmo s\u00e3o executadas de forma sequencial.</li> </ul>"}]}