## Projeto de Algoritmos

O passo final do pensamento computacional é criar uma sequência de instruções que resolve o problema. O ponto chave é guiar o raciocínio. Para tanto, é preciso considerar uma série de coisas. Qual o objetivo principal? Como abstrair o contexto? Como decompô-lo em partes mais acessíveis? Em que ordem estas partes devem ser tratadas?

!!! info "Pensamento Algorítmico"

    Processo de construir uma sequência de passos ordenados que pode ser seguida para obter uma solução para todos os problemas constituintes necessários para resolver o problema original[@Cansu2019].

A aplicação do pensamento algorítmico depende de certas informações sobre o problema. Quais as informações fornecidas? O que se espera como resultado? O que se deve fazer depende de certas condições? Há alguma parte que precisa ser repetida?

!!! note

    Duas ideias que ajudam este processo são: 1) se perguntar "E se eu fizesse desse jeito?" (explorando formas diferentes de resolver o problema); e 2) explicar a sua solução a alguém (ou a um [pato de borracha](https://pt.wikipedia.org/wiki/Debug_com_Pato_de_Borracha)), ao tentar ensinar uma solução [você estará efetivamente aprendendo sobre ela](https://degraucultural.com.br/noticia/ensinar-e-uma-das-melhores-formas-de-aprender-entenda).

Com um entendimento adequado do problema e seu contexto, pode-se projetar o algoritmo. Mais detalhes sobre isso serão discutidos no próximo capítulo, mas o grande [Richard Feynman](https://pt.wikipedia.org/wiki/Richard_Feynman) tem um abordagem praticamente infalível para isso:

``` mermaid title="Abordagem Feyman de Resolução de Problemas"
flowchart TD
    I([Início]) --> P[/Obtenha as informações do problema./] --> E[/Escreva o problema/] --> P2[Pense muito sobre o problema] --> E2[/Escreva a solução do problema/] --> F([Fim])
```

É claro, alguns problemas [não têm solução](https://pt.wikipedia.org/wiki/Lista_de_problemas_em_aberto) e outra abordagem seria "consigo mostrar que ele não pode ser resolvido?" (e assim determinar a solução que é "não é possível resolver"). Independentemente, a parte mais importante do pensamento computacional é, obviamente, o raciocínio aplicado no projeto da solução.







## Automação

O uso de mecanismos para realização de um processo específico tem uma série de vantagens. Provavelmente aumenta a eficiência na produção dos resultados e a uniformidade destes, reduz a incidência de erros e viabiliza o recurso humano para lidar com outras atividades. Além disso, muitas tarefas cotidianas são repetitivas e poderiam ser realizadas por um computador dadas as instruções corretas[@Sweigart2020].

Parte importante deste processo é o entendimento do que pode ser computado e também do que não pode ser. O computador existe como entidade física e opera dentro de certos limites. Portanto, apesar de podermos planejar soluções matematicamente corretas, é possível que estas não possam ser executadas na máquina. Por exemplo, há [métodos para calcular o valor exato de π](https://pt.wikipedia.org/wiki/Pi#M%C3%A9todos_de_s%C3%A9ries_infinitas), mas o resultado é um valor irracional e o processo para calcular o valor exato também é infinitamente demorado!

$$\pi = 4\cdot\sum\limits_{n=0}^{\infty}\frac{(-1)^n}{2n+1}$$

Além disso, certas operações podem demandar que uma quantidade inviável de informações seja armazenada, ou que sejam realizados tantos processos que se torna impraticável aguardar o término da computação (se ocorrer). O processo de formulação de uma solução algorítmica necessariamente deve considerar essas limitações de modo a chegar a uma opção que seja realizável.

Outro aspecto relevante neste processo é que, para ser realizada por um computador, a tarefa e deve ser programada de tal modo que os padrões de interação envolvidos escondam, mas não retirem os detalhes do contexto. Em Ciência da Computação, essa abstração é o processo de eliminar especificidades ao ignorar certas características e de esconder informações que não sejam necessárias[@Colburn2007], o que permite que os padrões de interações entre processos sejam aplicáveis em diversos contextos.
